

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Pandaos">
  <meta name="keywords" content="">
  
  <title>Microcode 插件学习 - Pandaos&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"panda0s.top","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Pandaos's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Panadaos</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss-fill"></i>
                Rss
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Microcode 插件学习">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-19 23:40" pubdate>
        August 19, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      193
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Microcode 插件学习</h1>
            
            <div class="markdown-body">
              <h1 id="Microcode-插件学习笔记"><a href="#Microcode-插件学习笔记" class="headerlink" title="Microcode 插件学习笔记"></a>Microcode 插件学习笔记</h1><p>plugins\hexrays_sdk\plugins 目录下有很多 demo 值得学习</p>
<p>20 个 demo 程序，断断续续分析了大概一个月的样子，最后还是发出来吧，毕竟这方面的资料太少了。</p>
<h2 id="一些基本的概念"><a href="#一些基本的概念" class="headerlink" title="一些基本的概念"></a>一些基本的概念</h2><p>Microcode 是 IDA 内部的一种介于机器语言与伪代码的之间的中间语言，用于抽象机器代码，便于后面的优化。</p>
<p>Microcode 展示插件: <a target="_blank" rel="noopener" href="https://github.com/gaasedelen/lucid">https://github.com/gaasedelen/lucid</a></p>
<p>Microcode 是分阶段生成的，类似与 llvm 中的 pass ，每个阶段 Microcode 都可以得到一定的优化，最终得到最优结果。</p>
<p>IDA 的 API 支持在 Microcode 生成之前调用用户的 Filter 重写机器指令到 Microcode 的翻译 (lift),  也支持用户自定义优化规则。用户自定义的优化规则包括指令间优化与基本块间的优化。</p>
<p>IDA 提供直接生成 Microcode 的 API 函数，并提供数据流信息，使得我们可以很方便地编写静态代码分析插件。</p>
<p>Microcode 生成完成后，IDA 在 Microcode 的基础上生成 CTree。 CTree 是 IDA 内部用于表示 C语言伪代码的抽象语法树，IDA 也提供了大量 API 操作 CTree，可以实现一下伪代码展示方面的优化，例如删除某些节点等等。</p>
<p>Microcode 可视化插件</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gaasedelen/lucid">https://github.com/gaasedelen/lucid</a></p>
<p>Ctree 可视化插件<br><a target="_blank" rel="noopener" href="https://github.com/patois/HRDevHelper">https://github.com/patois/HRDevHelper</a></p>
<p>Microcode 指令格式</p>
<p>opcode left, right, destination<br>一般来说有三个操作数，有一些指令可能缺少某个操作数，destination 也不一定会被修改（Store 指令）</p>
<p>每一个操作数都带有一个宽度描述符，描述的是该操作数的字节大小，例如 <code>eax.4</code> 表示 eax 是一个 4 字节的操作数。</p>
<p>Microcode 中的寄存器</p>
<p>Microcode 中寄存器都是虚拟寄存器，寄存器的数量没有限制。一般情况，物理寄存器会直接映射到虚拟寄存器。</p>
<p>Microcode 中常见的数据结构</p>
<p>函数是 IDA 中最大的汇编结果表示单位</p>
<p>函数 → 基本块 → 指令 → 操作数</p>
<p>每一级都有对应的数据结构来表示。</p>
<p><code>mbl_array_t</code> 可以说是最顶层的数据结构，每个函数都拥有该类型的字段，存储了基本块信息。</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>基本块是一个双向链表，其对应的类型是 <code>mblock_t</code> 。注意基本块本身逻辑前驱与后继由 <code>mblock_t</code> 内部的 <code>predset</code> 和 <code>succset</code> 维护而不是由双向链表维护。在上图中，natural 以数组形式存放基本块。</p>
<p><code>mblock_t</code> 的结构如下</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled1.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>基本块内的指令也是以双向链表的形式组织，指令的类型是 <code>minsn_t</code></p>
<p><code>minsn_t</code> 的结构图如下</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled2.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>你没有看错，这其实是一条指令，只不过该指令由多条指令嵌套而来。IDA 允许指令的操作数是另一条指令的 dest, 这使得在做一些优化的时候很方便，我们在后面会多次遇到这种情况。最顶层的指令叫做 top-level 指令，在 <code>mblock_t</code> 链表中存放的指令就只有 top-level 指令。指令的下一级是操作数，对应的数据结构是 <code>mop_t</code></p>
<p><code>mop_t</code> 结构的定义如下</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled3.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>在<code>mop_t</code> 结构中我们可以很容易的找到 <code>mop_t</code> 对嵌套指令的支持。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我调试的环境用的 VS2019 。经过我测试，VS2019 可以编译 IDA  7.6 插件并顺利运行和调试。</p>
<p>贴一下 VS的配置项</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled4.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>调试配置</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled5.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>包含目录 (Include 目录) 添加 sdk 目录与 plugin 的 include 目录</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled6.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>库目录添加上 ida sdk 的预编译库目录</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled7.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>添加链接器参数</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled8.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>/EXPORT:PLUGIN</p>
<h2 id="vds1"><a href="#vds1" class="headerlink" title="vds1"></a>vds1</h2><p>在 output-windows 输出指定函数的伪代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">func_t</span>* pfn = get_func(get_screen_ea());<br><span class="hljs-keyword">hexrays_failure_t</span> hf;<br><span class="hljs-keyword">cfuncptr_t</span> cfunc = decompile(pfn, &amp;hf, DECOMP_WARNINGS);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">strvec_t</span>&amp; sv = cfunc-&gt;get_pseudocode();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sv.size(); i++)<br>&#123;<br>    qstring buf;<br>    tag_remove(&amp;buf, sv[i].line);<br>    msg(<span class="hljs-string">&quot;%s\\n&quot;</span>, buf.c_str());<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>cfuncptr_t 的定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// Decompiled function. Decompilation result is kept here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfunc_t</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">ea_t</span> entry_ea;             <span class="hljs-comment">///&lt; function entry address</span><br>  <span class="hljs-keyword">mba_t</span> *mba;                <span class="hljs-comment">///&lt; underlying microcode</span><br>  <span class="hljs-keyword">cinsn_t</span> body;              <span class="hljs-comment">///&lt; function body, must be a block</span><br>  <span class="hljs-keyword">intvec_t</span> &amp;argidx;          <span class="hljs-comment">///&lt; list of arguments (indexes into vars)</span><br>  <span class="hljs-keyword">ctree_maturity_t</span> maturity; <span class="hljs-comment">///&lt; maturity level</span><br>  <span class="hljs-comment">// The following maps must be accessed using helper functions.</span><br>  <span class="hljs-comment">// Example: for user_labels_t, see functions starting with &quot;user_labels_&quot;.</span><br>  <span class="hljs-keyword">user_labels_t</span> *user_labels;<span class="hljs-comment">///&lt; user-defined labels.</span><br>  <span class="hljs-keyword">user_cmts_t</span> *user_cmts;    <span class="hljs-comment">///&lt; user-defined comments.</span><br>  <span class="hljs-keyword">user_numforms_t</span> *numforms; <span class="hljs-comment">///&lt; user-defined number formats.</span><br>  <span class="hljs-keyword">user_iflags_t</span> *user_iflags;<span class="hljs-comment">///&lt; user-defined item flags \\ref CIT_</span><br>  <span class="hljs-keyword">user_unions_t</span> *user_unions;<span class="hljs-comment">///&lt; user-defined union field selections.</span><br><span class="hljs-comment">/// \\defgroup CIT_ ctree item iflags bits</span><br><span class="hljs-comment">//@&#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CIT_COLLAPSED 0x0001 <span class="hljs-comment">///&lt; display element in collapsed form</span></span><br><span class="hljs-comment">//@&#125;</span><br>  <span class="hljs-keyword">int</span> refcnt;                <span class="hljs-comment">///&lt; reference count to this object. use cfuncptr_t</span><br>  <span class="hljs-keyword">int</span> statebits;             <span class="hljs-comment">///&lt; current cfunc_t state. see \\ref CFS_</span><br><span class="hljs-comment">/// \\defgroup CFS_ cfunc state bits</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_BOUNDS       0x0001 <span class="hljs-comment">///&lt; &#x27;eamap&#x27; and &#x27;boundaries&#x27; are ready</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_TEXT         0x0002 <span class="hljs-comment">///&lt; &#x27;sv&#x27; is ready (and hdrlines)</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_LVARS_HIDDEN 0x0004 <span class="hljs-comment">///&lt; local variable definitions are collapsed</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFS_LOCKED       0x0008 <span class="hljs-comment">///&lt; cfunc is temporarily locked</span></span><br>  <span class="hljs-keyword">eamap_t</span> *eamap;            <span class="hljs-comment">///&lt; ea-&gt;insn map. use \\ref get_eamap</span><br>  <span class="hljs-keyword">boundaries_t</span> *boundaries;  <span class="hljs-comment">///&lt; map of instruction boundaries. use \\ref get_boundaries</span><br>  <span class="hljs-keyword">strvec_t</span> sv;               <span class="hljs-comment">///&lt; decompilation output: function text. use \\ref get_pseudocode</span><br>  <span class="hljs-keyword">int</span> hdrlines;              <span class="hljs-comment">///&lt; number of lines in the declaration area</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">ctree_items_t</span> treeitems; <span class="hljs-comment">///&lt; vector of ctree items</span><br><br>  <span class="hljs-comment">// the exact size of this class is not documented, there may be more fields</span><br>  <span class="hljs-keyword">char</span> reserved[];<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">cfunc_t</span>(<span class="hljs-keyword">mba_t</span> *mba);          <span class="hljs-comment">// use create_cfunc()</span><br>  ~<span class="hljs-keyword">cfunc_t</span>(<span class="hljs-keyword">void</span>) &#123; cleanup(); &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; &#125;<br>  HEXRAYS_MEMORY_ALLOCATION_FUNCS()<br><br>  <span class="hljs-comment">/// Generate the function body.</span><br>  <span class="hljs-comment">/// This function (re)generates the function body from the underlying microcode.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">build_c_tree</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Verify the ctree.</span><br>  <span class="hljs-comment">/// This function verifies the ctree. If the ctree is malformed, an internal error</span><br>  <span class="hljs-comment">/// is generated. Use it to verify the ctree after your modifications.</span><br>  <span class="hljs-comment">/// \\param aul Are unused labels acceptable?</span><br>  <span class="hljs-comment">/// \\param even_without_debugger if false and there is no debugger, the verification will be skipped</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">verify</span><span class="hljs-params">(<span class="hljs-keyword">allow_unused_labels_t</span> aul, <span class="hljs-keyword">bool</span> even_without_debugger)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Print function prototype.</span><br>  <span class="hljs-comment">/// \\param vout output buffer</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">print_dcl</span><span class="hljs-params">(qstring *vout)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Print function text.</span><br>  <span class="hljs-comment">/// \\param vp printer helper class to receive the generated text.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">print_func</span><span class="hljs-params">(<span class="hljs-keyword">vc_printer_t</span> &amp;vp)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Get the function type.</span><br>  <span class="hljs-comment">/// \\param type variable where the function type is returned</span><br>  <span class="hljs-comment">/// \\return false if failure</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">get_func_type</span><span class="hljs-params">(<span class="hljs-keyword">tinfo_t</span> *type)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Get vector of local variables.</span><br>  <span class="hljs-comment">/// \\return pointer to the vector of local variables. If you modify this vector,</span><br>  <span class="hljs-comment">///         the ctree must be regenerated in order to have correct cast operators.</span><br>  <span class="hljs-comment">///         Use build_c_tree() for that.</span><br>  <span class="hljs-comment">///         Removing lvars should be done carefully: all references in ctree</span><br>  <span class="hljs-comment">///         and microcode must be corrected after that.</span><br>  <span class="hljs-function"><span class="hljs-keyword">lvars_t</span> *hexapi <span class="hljs-title">get_lvars</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Get stack offset delta.</span><br>  <span class="hljs-comment">/// The local variable stack offsets retrieved by v.location.stkoff()</span><br>  <span class="hljs-comment">/// should be adjusted before being used as stack frame offsets in IDA.</span><br>  <span class="hljs-comment">/// \\return the delta to apply.</span><br>  <span class="hljs-comment">///         example: ida_stkoff = v.location.stkoff() - f-&gt;get_stkoff_delta()</span><br>  <span class="hljs-function"><span class="hljs-keyword">sval_t</span> hexapi <span class="hljs-title">get_stkoff_delta</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Find the label.</span><br>  <span class="hljs-comment">/// \\return pointer to the ctree item with the specified label number.</span><br>  <span class="hljs-function"><span class="hljs-keyword">citem_t</span> *hexapi <span class="hljs-title">find_label</span><span class="hljs-params">(<span class="hljs-keyword">int</span> label)</span></span>;<br><br>  <span class="hljs-comment">/// Remove unused labels.</span><br>  <span class="hljs-comment">/// This function check what labels are really used by the function and</span><br>  <span class="hljs-comment">/// removes the unused ones.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">remove_unused_labels</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Retrieve a user defined comment.</span><br>  <span class="hljs-comment">/// \\param loc ctree location</span><br>  <span class="hljs-comment">/// \\param rt should already retrieved comments retrieved again?</span><br>  <span class="hljs-comment">/// \\return pointer to the comment string or NULL</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *hexapi <span class="hljs-title">get_user_cmt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">treeloc_t</span> &amp;loc, <span class="hljs-keyword">cmt_retrieval_type_t</span> rt)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Set a user defined comment.</span><br>  <span class="hljs-comment">/// This function stores the specified comment in the cfunc_t structure.</span><br>  <span class="hljs-comment">/// The save_user_cmts() function must be called after it.</span><br>  <span class="hljs-comment">/// \\param loc ctree location</span><br>  <span class="hljs-comment">/// \\param cmt new comment. if empty or NULL, then an existing comment is deleted.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">set_user_cmt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">treeloc_t</span> &amp;loc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cmt)</span></span>;<br><br>  <span class="hljs-comment">/// Retrieve citem iflags.</span><br>  <span class="hljs-comment">/// \\param loc citem locator</span><br>  <span class="hljs-comment">/// \\return \\ref CIT_ or 0</span><br>  <span class="hljs-function">int32 hexapi <span class="hljs-title">get_user_iflags</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">citem_locator_t</span> &amp;loc)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Set citem iflags.</span><br>  <span class="hljs-comment">/// \\param loc citem locator</span><br>  <span class="hljs-comment">/// \\param iflags new iflags</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">set_user_iflags</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">citem_locator_t</span> &amp;loc, int32 iflags)</span></span>;<br><br>  <span class="hljs-comment">/// Check if there are orphan comments.</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">has_orphan_cmts</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Delete all orphan comments.</span><br>  <span class="hljs-comment">/// The save_user_cmts() function must be called after this call.</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> hexapi <span class="hljs-title">del_orphan_cmts</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Retrieve a user defined union field selection.</span><br>  <span class="hljs-comment">/// \\param ea address</span><br>  <span class="hljs-comment">/// \\param path out: path describing the union selection.</span><br>  <span class="hljs-comment">/// \\return pointer to the path or NULL</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">get_user_union_selection</span><span class="hljs-params">(<span class="hljs-keyword">ea_t</span> ea, <span class="hljs-keyword">intvec_t</span> *path)</span></span>;<br><br>  <span class="hljs-comment">/// Set a union field selection.</span><br>  <span class="hljs-comment">/// The save_user_unions() function must be called after calling this function.</span><br>  <span class="hljs-comment">/// \\param ea address</span><br>  <span class="hljs-comment">/// \\param path in: path describing the union selection.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">set_user_union_selection</span><span class="hljs-params">(<span class="hljs-keyword">ea_t</span> ea, <span class="hljs-keyword">const</span> <span class="hljs-keyword">intvec_t</span> &amp;path)</span></span>;<br><br>  <span class="hljs-comment">/// Save user-defined labels into the database</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">save_user_labels</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-comment">/// Save user-defined comments into the database</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">save_user_cmts</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-comment">/// Save user-defined number formats into the database</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">save_user_numforms</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-comment">/// Save user-defined iflags into the database</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">save_user_iflags</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-comment">/// Save user-defined union field selections into the database</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">save_user_unions</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span></span>;<br><br>  <span class="hljs-comment">/// Get ctree item for the specified cursor position.</span><br>  <span class="hljs-comment">/// \\return false if failed to get the current item</span><br>  <span class="hljs-comment">/// \\param line line of decompilation text (element of \\ref sv)</span><br>  <span class="hljs-comment">/// \\param x x cursor coordinate in the line</span><br>  <span class="hljs-comment">/// \\param is_ctree_line does the line belong to statement area? (if not, it is assumed to belong to the declaration area)</span><br>  <span class="hljs-comment">/// \\param phead ptr to the first item on the line (used to attach block comments). May be NULL</span><br>  <span class="hljs-comment">/// \\param pitem ptr to the current item. May be NULL</span><br>  <span class="hljs-comment">/// \\param ptail ptr to the last item on the line (used to attach indented comments). May be NULL</span><br>  <span class="hljs-comment">/// \\sa vdui_t::get_current_item()</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">get_line_item</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *line,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> x,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">bool</span> is_ctree_line,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">ctree_item_t</span> *phead,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">ctree_item_t</span> *pitem,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">ctree_item_t</span> *ptail)</span></span>;<br><br>  <span class="hljs-comment">/// Get information about decompilation warnings.</span><br>  <span class="hljs-comment">/// \\return reference to the vector of warnings</span><br>  <span class="hljs-function"><span class="hljs-keyword">hexwarns_t</span> &amp;hexapi <span class="hljs-title">get_warnings</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Get pointer to ea-&gt;insn map.</span><br>  <span class="hljs-comment">/// This function initializes eamap if not done yet.</span><br>  <span class="hljs-function"><span class="hljs-keyword">eamap_t</span> &amp;hexapi <span class="hljs-title">get_eamap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Get pointer to map of instruction boundaries.</span><br>  <span class="hljs-comment">/// This function initializes the boundary map if not done yet.</span><br>  <span class="hljs-function"><span class="hljs-keyword">boundaries_t</span> &amp;hexapi <span class="hljs-title">get_boundaries</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Get pointer to decompilation output: the pseudocode.</span><br>  <span class="hljs-comment">/// This function generates pseudocode if not done yet.</span><br>  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">strvec_t</span> &amp;hexapi <span class="hljs-title">get_pseudocode</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-comment">/// Refresh ctext after a ctree modification.</span><br>  <span class="hljs-comment">/// This function informs the decompiler that ctree (\\ref body) have been</span><br>  <span class="hljs-comment">/// modified and ctext (\\ref sv) does not correspond to it anymore.</span><br>  <span class="hljs-comment">/// It also refreshes the pseudocode windows if there is any.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">refresh_func_ctext</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">gather_derefs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ctree_item_t</span> &amp;ci, <span class="hljs-keyword">udt_type_data_t</span> *udm=<span class="hljs-literal">NULL</span>)</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">find_item_coords</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">citem_t</span> *item, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">locked</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> (statebits &amp; CFS_LOCKED) != <span class="hljs-number">0</span>; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/// Cleanup.</span><br>  <span class="hljs-comment">/// Properly delete all children and free memory.</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> hexapi <span class="hljs-title">cleanup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br>  DECLARE_UNCOPYABLE(<span class="hljs-keyword">cfunc_t</span>)<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">qrefcnt_t</span>&lt;<span class="hljs-keyword">cfunc_t</span>&gt; <span class="hljs-keyword">cfuncptr_t</span>;<br><br></code></pre></td></tr></table></figure>

<h2 id="vds2"><a href="#vds2" class="headerlink" title="vds2"></a>vds2</h2><p>这个插件将指针中的 0 替换成 Null。<br>IDA 的反编译结果经常是动态变化的，为了实现这个任务，这个插件通过注册 IDA 的 hexrays 事件回调，当 ctree 生成完成后立即对 ctree 中的 0 进行替换。</p>
<p>注册 hexrays 回调</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">install_hexrays_callback(hr_callback, <span class="hljs-literal">nullptr</span>);<br>remove_hexrays_callback(hr_callback, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 取消回调</span><br><br></code></pre></td></tr></table></figure>

<p>回调函数中判断回调的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This callback will detect when the ctree is ready to be displayed</span><br><span class="hljs-comment">// and call convert_zeroes() to create NULLs</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> idaapi <span class="hljs-title">plugin_ctx_t::hr_callback</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">void</span>*,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">hexrays_event_t</span> event,</span></span><br><span class="hljs-function"><span class="hljs-params">    va_list va)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (event == hxe_maturity)<br>    &#123;<br>        <span class="hljs-keyword">cfunc_t</span>* cfunc = va_arg(va, <span class="hljs-keyword">cfunc_t</span>*);<br>        <span class="hljs-keyword">ctree_maturity_t</span> mat = va_argi(va, <span class="hljs-keyword">ctree_maturity_t</span>);<br>        <span class="hljs-keyword">if</span> (mat == CMAT_FINAL) <span class="hljs-comment">// ctree is ready, time to convert zeroes to NULLs</span><br>            convert_zeroes(cfunc);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>event 参数由 IDA 传入回调类型，全部的回调类型与说明可以查看 hexrays.hpp 中 <code>enum hexrays_event_t</code> 定义代码与注释。<br><code>hxe_maturity</code> 回调会在 Ctree maturity 改变时调用，并且变参列表 va 的参数是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">cfunc_t</span> * cfunc<br><span class="hljs-keyword">ctree_maturity_t</span> new_maturity<br><br></code></pre></td></tr></table></figure>

<p>Ctree 与 MicroCode 一样，也是分阶段生成的，最后一个阶段叫做 <code>CMAT_FINAL</code>.<br>该插件还会进一步判断 maturity 阶段，当完成最后的阶段后才调用 <code>convert_zeroes</code> 函数对目标函数进行进一步处理。</p>
<p>convert_zeroes 函数代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Convert zeroes of the ctree to NULLs</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convert_zeroes</span><span class="hljs-params">(<span class="hljs-keyword">cfunc_t</span>* cfunc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// To represent NULLs, we will use the MACRO_NULL enumeration</span><br>    <span class="hljs-comment">// Normally it is present in the loaded tils but let&#x27;s verify it</span><br>    <span class="hljs-keyword">if</span> (!get_named_type(<span class="hljs-literal">NULL</span>, null_type, NTF_TYPE))<br>    &#123;<br>        msg(<span class="hljs-string">&quot;%s type is missing, cannot convert zeroes to NULLs\\n&quot;</span>, null_type);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// We derive a helper class from ctree_visitor_t</span><br>    <span class="hljs-comment">// The ctree_visitor_t is a base class to derive</span><br>    <span class="hljs-comment">// ctree walker classes.</span><br>    <span class="hljs-comment">// You have to redefine some virtual functions</span><br>    <span class="hljs-comment">// to do the real job. Here we redefine visit_expr() since we want</span><br>    <span class="hljs-comment">// to examine and modify expressions.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ida_local</span> <span class="hljs-title">zero_converter_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">ctree_visitor_t</span><br>    &#123;<br>        <span class="hljs-keyword">zero_converter_t</span>(<span class="hljs-keyword">void</span>) : <span class="hljs-keyword">ctree_visitor_t</span>(CV_FAST) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_expr</span><span class="hljs-params">(<span class="hljs-keyword">cexpr_t</span>* e)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">// verify if the current expression has pointer expressions</span><br>            <span class="hljs-comment">// we handle the following patterns:</span><br>            <span class="hljs-comment">//  A. ptr = 0;</span><br>            <span class="hljs-comment">//  B. func(0); where argument is a pointer</span><br>            <span class="hljs-comment">//  C. ptr op 0 where op is a comparison</span><br>            <span class="hljs-keyword">switch</span> (e-&gt;op)<br>            &#123;<br>            <span class="hljs-keyword">case</span> cot_asg:   <span class="hljs-comment">// A cot_asg: x = y</span><br>                <span class="hljs-keyword">if</span> (e-&gt;x-&gt;type.is_ptr()) <span class="hljs-comment">// e-&gt;x first operand</span><br>                    make_null_if_zero(e-&gt;y);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> cot_call:  <span class="hljs-comment">// B</span><br>            &#123;<br>                <span class="hljs-keyword">carglist_t</span>&amp; args = *e-&gt;a;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.size(); i++) <span class="hljs-comment">// check all arguments</span><br>                &#123;<br>                    <span class="hljs-keyword">carg_t</span>&amp; a = args[i];<br>                    <span class="hljs-keyword">if</span> (a.formal_type.is_ptr_or_array())<br>                        make_null_if_zero(&amp;a);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> cot_eq:    <span class="hljs-comment">// C</span><br>            <span class="hljs-keyword">case</span> cot_ne:<br>            <span class="hljs-keyword">case</span> cot_sge:<br>            <span class="hljs-keyword">case</span> cot_uge:<br>            <span class="hljs-keyword">case</span> cot_sle:<br>            <span class="hljs-keyword">case</span> cot_ule:<br>            <span class="hljs-keyword">case</span> cot_sgt:<br>            <span class="hljs-keyword">case</span> cot_ugt:<br>            <span class="hljs-keyword">case</span> cot_slt:<br>            <span class="hljs-keyword">case</span> cot_ult:<br>                <span class="hljs-comment">// check both sides for zeroes</span><br>                <span class="hljs-keyword">if</span> (e-&gt;y-&gt;type.is_ptr()) <span class="hljs-comment">// e-&gt;y second operand</span><br>                    make_null_if_zero(e-&gt;x);<br>                <span class="hljs-keyword">if</span> (e-&gt;x-&gt;type.is_ptr())<br>                    make_null_if_zero(e-&gt;y);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// continue walking the tree</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">zero_converter_t</span> zc;<br>    <span class="hljs-comment">// walk the whole function body</span><br>    zc.apply_to(&amp;cfunc-&gt;body, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码定义一个类 <code>zero_converter_t</code> 继承于 <code>ctree_visitor_t</code>，用观察者模式来访问函数中的所有 ctree 节点。并针对三种语法节点中的<code>0</code>进行处理。</p>
<ol>
<li>ptr = 0;</li>
<li>func(0); where argument is a pointer</li>
<li>ptr op 0 where op is a comparison</li>
</ol>
<p>识别这三种语句的方法依赖于 Ctree 节点的 op 属性，匹配成功后调用 <code>make_null_if_zero</code> 进行进一步处理。<br>make_null_if_zero 代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// If the expression is zero, convert it to NULL</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">make_null_if_zero</span><span class="hljs-params">(<span class="hljs-keyword">cexpr_t</span>* e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;is_zero_const() &amp;&amp; !e-&gt;type.is_ptr())<br>    &#123; <span class="hljs-comment">// this is plain zero, convert it</span><br>        <span class="hljs-keyword">number_format_t</span>&amp; nf = e-&gt;n-&gt;nf;<br>        nf.flags = enum_flag(); <span class="hljs-comment">// nf.flags ida flags, which describe number radix, enum, etc</span><br>        nf.serial = <span class="hljs-number">0</span>;         <span class="hljs-comment">// for enums: constant serial number</span><br>        nf.props |= NF_VALID;<br>        nf.type_name = null_type;<br>        e-&gt;type.get_named_type(<span class="hljs-literal">nullptr</span>, null_type, BTF_ENUM);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>make_null_if_zero 代码中首先判断传入的表达式是否为 0 常量且类型是指针，如果是的话，将其类型改为 enum 并指定类型名为 MACRO_NULL</p>
<h3 id="python-实现版本"><a href="#python-实现版本" class="headerlink" title="python 实现版本"></a>python 实现版本</h3><p>python 版本仅供参考，目前我实现的这份代码在替换 0 为 Null 之后会导致 IDA Internal Error..不清楚是什么原因</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">def <span class="hljs-title">make_null_if_zero</span><span class="hljs-params">(expr: idaapi.<span class="hljs-keyword">cexpr_t</span>)</span>:</span><br><span class="hljs-function">    <span class="hljs-keyword">if</span> expr.<span class="hljs-title">is_zero_const</span><span class="hljs-params">()</span>:</span><br><span class="hljs-function">        <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;modify at:&quot;</span>, hex(expr.ea))</span></span><br><span class="hljs-function">        nf </span>= expr.n.nf<br>        nf.flags = idaapi.enum_flag()<br>        nf.serial = <span class="hljs-number">0</span><br>        nf.props = idaapi.NF_VALID<br>        nf.type_name = <span class="hljs-string">&quot;MACRO_NULL&quot;</span><br>        expr.type.get_named_type(None, <span class="hljs-string">&quot;MACRO_NULL&quot;</span>, idaapi.BTF_ENUM)<br><br>def convert_zeroes(cfunc: idaapi.<span class="hljs-keyword">cfunc_t</span>):<br>    class <span class="hljs-keyword">zero_converter_t</span>(idaapi.<span class="hljs-keyword">ctree_visitor_t</span>):<br>        def __init__(self, *args):<br>            super().__init__(idaapi.CV_FAST)<br><br>        def visit_expr(self, *args) -&gt; <span class="hljs-string">&quot;int&quot;</span>:<br>            e = args[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> e.op == idaapi.cot_asg: # A<br>                <span class="hljs-keyword">if</span> e.x.type.is_ptr():<br>                    make_null_if_zero(e.y)<br>            <span class="hljs-keyword">if</span> e.op == idaapi.cot_call: # B<br>                <span class="hljs-keyword">for</span> arg in e.a:<br>                    <span class="hljs-keyword">if</span> arg.formal_type.is_ptr_or_array():<br>                        make_null_if_zero(arg)<br>            <span class="hljs-keyword">if</span> e.op in [idaapi.cot_eq, idaapi.cot_ne, idaapi.cot_sge, idaapi.cot_uge, idaapi.cot_sle,idaapi.cot_ule, idaapi.cot_sgt, idaapi.cot_ugt, idaapi.cot_slt, idaapi.cot_ult]:<br>                <span class="hljs-keyword">if</span> e.y.type.is_ptr():<br>                    make_null_if_zero(e.x)<br>                elif e.x.type.is_ptr():<br>                    make_null_if_zero(e.y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>    zc = <span class="hljs-keyword">zero_converter_t</span>()<br>    zc.apply_to(cfunc.body, None)<br><br>class <span class="hljs-keyword">vds2_hook_t</span>(idaapi.Hexrays_Hooks):<br>    def __init__(self, *args):<br>        super().__init__(*args)<br><br>    def maturity(self, *args) -&gt; <span class="hljs-string">&quot;int&quot;</span>: <span class="hljs-meta"># alias for hxe_maturity</span><br>        mat = args[<span class="hljs-number">1</span>]<br>        cfunc = args[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> mat == idaapi.CMAT_FINAL:<br>            convert_zeroes(cfunc)<br>        <span class="hljs-keyword">return</span> super().maturity(*args)<br>vds2_hooks = <span class="hljs-keyword">vds2_hook_t</span>()<br>vds2_hooks.hook()<br># vds2_hooks.unhook()<br><br></code></pre></td></tr></table></figure>

<h2 id="vds3"><a href="#vds3" class="headerlink" title="vds3"></a>vds3</h2><p>这个插件能够将反转 if 语句的条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *      if ( cond )</span><br><span class="hljs-comment"> *      &#123;</span><br><span class="hljs-comment"> *        statements1;</span><br><span class="hljs-comment"> *      &#125;</span><br><span class="hljs-comment"> *      else</span><br><span class="hljs-comment"> *      &#123;</span><br><span class="hljs-comment"> *        statements2;</span><br><span class="hljs-comment"> *      &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      if ( !cond )</span><br><span class="hljs-comment"> *      &#123;</span><br><span class="hljs-comment"> *        statements2;</span><br><span class="hljs-comment"> *      &#125;</span><br><span class="hljs-comment"> *      else</span><br><span class="hljs-comment"> *      &#123;</span><br><span class="hljs-comment"> *        statements1;</span><br><span class="hljs-comment"> *      &#125;</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>

<p>ctree 被修改后是一次性的，如果 ctree 重新创建，则之前的修改就会失效.为了持久化, 该插件将修改信息存储在了 database，并在每一次 ctree 创建完成后重新对记录生效, 即使用户退出并重启 IDA 也是生效的。</p>
<h3 id="handler-分析"><a href="#handler-分析" class="headerlink" title="handler 分析"></a>handler 分析</h3><p>handler 代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">-----------------------------<br><span class="hljs-comment">// This callback handles various hexrays events.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> idaapi <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ud, <span class="hljs-keyword">hexrays_event_t</span> event, va_list va)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">vds3_t</span>* plugmod = (<span class="hljs-keyword">vds3_t</span>*)ud;<br>    <span class="hljs-keyword">switch</span> (event)<br>    &#123;<br>    <span class="hljs-keyword">case</span> hxe_populating_popup:<br>    &#123; <span class="hljs-comment">// If the current item is an if-statement, then add the menu item</span><br>        TWidget* widget = va_arg(va, TWidget*);<br>        TPopupMenu* popup = va_arg(va, TPopupMenu*);<br>        <span class="hljs-keyword">vdui_t</span>&amp; vu = *va_arg(va, <span class="hljs-keyword">vdui_t</span>*);<br>        <span class="hljs-keyword">if</span> (plugmod-&gt;find_if_statement(vu) != <span class="hljs-literal">NULL</span>)<br>            attach_action_to_popup(widget, popup, ACTION_NAME);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> hxe_maturity:<br>        <span class="hljs-keyword">if</span> (!plugmod-&gt;inverted_ifs.empty())<br>        &#123; <span class="hljs-comment">// If the ctree is ready, invert marked ifs</span><br>            <span class="hljs-keyword">cfunc_t</span>* cfunc = va_arg(va, <span class="hljs-keyword">cfunc_t</span>*);<br>            <span class="hljs-keyword">ctree_maturity_t</span> new_maturity = va_argi(va, <span class="hljs-keyword">ctree_maturity_t</span>);<br>            <span class="hljs-keyword">if</span> (new_maturity == CMAT_FINAL) <span class="hljs-comment">// ctree is ready</span><br>                plugmod-&gt;convert_marked_ifs(cfunc);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>handler 代码分别处理了 <code>hxe_populating_popup</code> 与 <code>hxe_maturity</code> 事件。</p>
<h3 id="hxe-populating-popup"><a href="#hxe-populating-popup" class="headerlink" title="hxe_populating_popup"></a>hxe_populating_popup</h3><p>对于 <code>hxe_populating_popup</code> 事件，先判断用户选中的代码是否为 if-statement ，若是的话在菜单中插入 “”sample3:invertif” 选项。<br>该事件的第二个参数的类型是 <code>vdui_t</code> ，该参数用来描述用户在 pseudocode 窗口中选中项目的一些属性。</p>
<p>vds3_t::find_if_statement 的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Check if the item under the cursor is &#x27;if&#x27; or &#x27;else&#x27; keyword</span><br><span class="hljs-comment">// If yes, return pointer to the corresponding ctree item</span><br><span class="hljs-function"><span class="hljs-keyword">cinsn_t</span>* <span class="hljs-title">vds3_t::find_if_statement</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">vdui_t</span>&amp; vu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// &#x27;if&#x27; keyword: straightforward check</span><br>    <span class="hljs-keyword">if</span> (vu.item.is_citem())<br>    &#123;<br>        <span class="hljs-keyword">cinsn_t</span>* i = vu.item.i;<br>        <span class="hljs-comment">// we can handle only if-then-else statements, so check that the &#x27;else&#x27;</span><br>        <span class="hljs-comment">// clause exists</span><br>        <span class="hljs-keyword">if</span> (i-&gt;op == cit_if &amp;&amp; i-&gt;cif-&gt;ielse != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-comment">// check for &#x27;else&#x27; line. The else lines do not correspond</span><br>    <span class="hljs-comment">// to any ctree item. That&#x27;s why we have to check for them separately.</span><br>    <span class="hljs-comment">// we could extract the corresponding text line but this would be a bad approach</span><br>    <span class="hljs-comment">// a line with single &#x27;else&#x27; would not give us enough information to locate</span><br>    <span class="hljs-comment">// the corresponding &#x27;if&#x27;. That&#x27;s why we use the line tail marks.</span><br>    <span class="hljs-comment">// All &#x27;else&#x27; line will have the ITP_ELSE mark</span><br>    <span class="hljs-keyword">if</span> (vu.tail.citype == VDI_TAIL &amp;&amp; vu.tail.loc.itp == ITP_ELSE)<br>    &#123;<br>        <span class="hljs-comment">// for tail marks, we know only the corresponding ea,</span><br>        <span class="hljs-comment">// not the pointer to if-statement</span><br>        <span class="hljs-comment">// find it by walking the whole ctree</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ida_local</span> <span class="hljs-title">if_finder_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">ctree_visitor_t</span><br>        &#123;<br>            <span class="hljs-keyword">ea_t</span> ea;<br>            <span class="hljs-keyword">cinsn_t</span>* found;<br>            <span class="hljs-keyword">if_finder_t</span>(<span class="hljs-keyword">ea_t</span> e)<br>                : <span class="hljs-keyword">ctree_visitor_t</span>(CV_FAST | CV_INSNS), ea(e), found(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>            <span class="hljs-function"><span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_insn</span><span class="hljs-params">(<span class="hljs-keyword">cinsn_t</span>* i)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">            </span>&#123;<br>                <span class="hljs-keyword">if</span> (i-&gt;op == cit_if &amp;&amp; i-&gt;ea == ea)<br>                &#123;<br>                    found = i;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// stop enumeration</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-function"><span class="hljs-keyword">if_finder_t</span> <span class="hljs-title">iff</span><span class="hljs-params">(vu.tail.loc.ea)</span></span>;<br>        <span class="hljs-keyword">if</span> (iff.apply_to(&amp;vu.cfunc-&gt;body, <span class="hljs-literal">NULL</span>))<br>            <span class="hljs-keyword">return</span> iff.found;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如果用户选中的是 if 且该 if 存在 else 就直接返回其对应的 ctree 指令对象指针。若用户选中的是 else，就有点复杂了。<br>else 在 ctree 中没有任何对应的项，只能通过 vdui_t 中提供的信息来判断，判断代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vu.tail.citype == VDI_TAIL &amp;&amp; vu.tail.loc.itp == ITP_ELSE<br><br></code></pre></td></tr></table></figure>

<p>识别出用户选中的 else 之后，需要在整个 ctree 中搜索该 else 对应的 if-statement, 并返回 if-statement 对应的指令。</p>
<h3 id="hxe-maturity"><a href="#hxe-maturity" class="headerlink" title="hxe_maturity"></a>hxe_maturity</h3><p>ctree 完成最后阶段生成后调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">plugmod-&gt;convert_marked_ifs(cfunc);<br><br></code></pre></td></tr></table></figure>

<h3 id="convert-marked-ifs-分析"><a href="#convert-marked-ifs-分析" class="headerlink" title="convert_marked_ifs 分析"></a>convert_marked_ifs 分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vds3_t::convert_marked_ifs</span><span class="hljs-params">(<span class="hljs-keyword">cfunc_t</span>* cfunc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// we walk the ctree and for each if-statement check if has to be inverted</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ida_local</span> <span class="hljs-title">if_inverter_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">ctree_visitor_t</span><br>    &#123;<br>        <span class="hljs-keyword">vds3_t</span>* self;<br>        <span class="hljs-keyword">if_inverter_t</span>(<span class="hljs-keyword">vds3_t</span>* _self)<br>            : <span class="hljs-keyword">ctree_visitor_t</span>(CV_FAST | CV_INSNS),<br>            self(_self) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_insn</span><span class="hljs-params">(<span class="hljs-keyword">cinsn_t</span>* i)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (i-&gt;op == cit_if &amp;&amp; self-&gt;inverted_ifs.has(i-&gt;ea))<br>                self-&gt;do_invert_if(i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// continue enumeration</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">if_inverter_t</span> <span class="hljs-title">ifi</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    ifi.apply_to(&amp;cfunc-&gt;body, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// go!</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码非常简单，遍历 cree 寻找 if-statement，并判断其是否需要反转。反转调用函数 <code>do_invert_if</code></p>
<h3 id="do-invert-if-分析"><a href="#do-invert-if-分析" class="headerlink" title="do_invert_if 分析"></a>do_invert_if 分析</h3><p>这是最核心的函数，即将 if 反转的核心函数，实际上非常简单，代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The user has selected to invert the if statement. Update ctree</span><br><span class="hljs-comment">// and refresh the view.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vds3_t::do_invert_if</span><span class="hljs-params">(<span class="hljs-keyword">cinsn_t</span>* i)</span> <span class="hljs-comment">//lint !e818 could be declared as const*</span></span><br><span class="hljs-function"></span>&#123;<br>    QASSERT(<span class="hljs-number">30198</span>, i-&gt;op == cit_if);<br>    <span class="hljs-keyword">cif_t</span>&amp; cif = *i-&gt;cif;<br>    <span class="hljs-comment">// create an inverted condition and swap it with the if-condition</span><br>    <span class="hljs-keyword">cexpr_t</span>* notcond = lnot(<span class="hljs-keyword">new</span> <span class="hljs-keyword">cexpr_t</span>(cif.expr));<br>    notcond-&gt;swap(cif.expr);<br>    <span class="hljs-keyword">delete</span> notcond;<br>    <span class="hljs-comment">// swap if branches</span><br>    qswap(cif.ielse, cif.ithen);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>该函数将输入的 if-statement 中的 expr 替换为 not expr，并交换 then 与 else 指令。</p>
<h2 id="vds4"><a href="#vds4" class="headerlink" title="vds4"></a>vds4</h2><p>略，与 ctree &amp; microcode 关系不大</p>
<h2 id="vds5"><a href="#vds5" class="headerlink" title="vds5"></a>vds5</h2><p>略，Ctree 图形化显示插件</p>
<h2 id="vds6"><a href="#vds6" class="headerlink" title="vds6"></a>vds6</h2><p>略，删除输出代码的空格</p>
<h2 id="vds7"><a href="#vds7" class="headerlink" title="vds7"></a>vds7</h2><p>这个插件演示了如何使用 <code>cblock_t::iterator</code><br>我们只关注核心代码，核心代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ida_local</span> <span class="hljs-title">cblock_visitor_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">ctree_visitor_t</span><br>&#123;<br>    <span class="hljs-keyword">cblock_visitor_t</span>(<span class="hljs-keyword">void</span>) : <span class="hljs-keyword">ctree_visitor_t</span>(CV_FAST) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_insn</span><span class="hljs-params">(<span class="hljs-keyword">cinsn_t</span>* ins)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (ins-&gt;op == cit_block)<br>            dump_block(ins-&gt;ea, ins-&gt;cblock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dump_block</span><span class="hljs-params">(<span class="hljs-keyword">ea_t</span> ea, <span class="hljs-keyword">cblock_t</span>* b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// iterate over all block instructions</span><br>        msg(<span class="hljs-string">&quot;dumping block %a\\n&quot;</span>, ea);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">cblock_t</span>::iterator p = b-&gt;begin(); p != b-&gt;end(); ++p)<br>        &#123;<br>            <span class="hljs-keyword">cinsn_t</span>&amp; i = *p;<br>            msg(<span class="hljs-string">&quot;  %a: insn %s\\n&quot;</span>, i.ea, get_ctype_name(i.op));<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">cblock_visitor_t</span> cbv;<br>cbv.apply_to(&amp;func-&gt;body, <span class="hljs-literal">NULL</span>);<br><br></code></pre></td></tr></table></figure>

<p><code>cblock_t::iterator</code> 的使用方式与 STL 的迭代器很相似，调用很方便。</p>
<h2 id="vds8"><a href="#vds8" class="headerlink" title="vds8"></a>vds8</h2><p>这个插件将 svc 0x900001 与 svc 0x9000F8 指令反编译成一条 call 指令, 这个功能与 IDA 菜单: Edit-&gt;Other-&gt;Decomile as call 类似。<br>实现方法是通过 <code>install_microcode_filter</code> 注册 microcode filter.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">udc_exit_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">udc_filter_t</span><br>&#123;<br>    <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">bool</span> installed;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">udc_exit_t</span>() : code(<span class="hljs-number">0</span>), installed(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> svc_code, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">char</span> decl[MAXSTR];<br>        qsnprintf(decl, <span class="hljs-keyword">sizeof</span>(decl), <span class="hljs-string">&quot;int __usercall %s@&lt;R0&gt;(int status@&lt;R1&gt;);&quot;</span>, name);<br>        <span class="hljs-keyword">bool</span> ok = init(decl);<br>        <span class="hljs-keyword">if</span> (!ok)<br>            msg(<span class="hljs-string">&quot;Could not initialize UDC plugin &#x27;%s&#x27;\\n&quot;</span>, name);<br>        code = svc_code;<br>        <span class="hljs-keyword">return</span> ok;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        install_microcode_filter(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>);<br>        installed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        install_microcode_filter(<span class="hljs-keyword">this</span>, <span class="hljs-literal">false</span>);<br>        installed = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toggle_install</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (installed)<br>            uninstall();<br>        <span class="hljs-keyword">else</span><br>            install();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">codegen_t</span>&amp; cdg)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> cdg.insn.itype == ARM_svc &amp;&amp; cdg.insn.Op1.value == code;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-keyword">udc_exit_t</span>() &#123;&#125; <span class="hljs-comment">// shut up a compiler warning</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><code>udc_exit_t</code> 类继承于 <code>udc_filter_t</code> 其定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// Abstract class: User-defined call generator</span><br><span class="hljs-comment">/// derived classes should implement method &#x27;match&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">udc_filter_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">microcode_filter_t</span><br>&#123;<br>  <span class="hljs-keyword">udcall_t</span> udc;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/// return true if the filter object should be appied to given instruction</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">codegen_t</span> &amp;cdg)</span> <span class="hljs-keyword">override</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *decl)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">merror_t</span> hexapi <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">codegen_t</span> &amp;cdg)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>我们进一步来学习一下 <code>microcode_filter_t</code> 的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//-------------------------------------------------------------------------</span><br><span class="hljs-comment">/// Generic microcode generator class.</span><br><span class="hljs-comment">/// An instance of a derived class can be registered to be used for</span><br><span class="hljs-comment">/// non-standard microcode generation. Before microcode generation for an</span><br><span class="hljs-comment">/// instruction all registered object will be visited by the following way:</span><br><span class="hljs-comment">///   if ( filter-&gt;match(cdg) )</span><br><span class="hljs-comment">///     code = filter-&gt;apply(cdg);</span><br><span class="hljs-comment">///   if ( code == MERR_OK )</span><br><span class="hljs-comment">///     continue;     // filter generated microcode, go to the next instruction</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">microcode_filter_t</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/// check if the filter object is to be appied</span><br>  <span class="hljs-comment">/// \\return success</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">codegen_t</span> &amp;cdg)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/// generate microcode for an instruction</span><br>  <span class="hljs-comment">/// \\return MERR_... code:</span><br>  <span class="hljs-comment">///   MERR_OK      - user-defined call generated, go to the next instruction</span><br>  <span class="hljs-comment">///   MERR_INSN    - not generated - the caller should try the standard way</span><br>  <span class="hljs-comment">///   else         - error</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">merror_t</span> <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">codegen_t</span> &amp;cdg)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>microcode_filter_t 的派生类可以用于非标准的 microcode 生成. 在 microcode 生成指令之前，所有注册的 filter 都将以如下形式调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ( filter-&gt;match(cdg) )<br>    code = filter-&gt;apply(cdg);<br><span class="hljs-keyword">if</span> ( code == MERR_OK )<br>    <span class="hljs-keyword">continue</span>;     <span class="hljs-comment">// filter generated microcode, go to the next instruction</span><br><br></code></pre></td></tr></table></figure>

<p>回到 <code>udc_filter_t</code>该类要求子类实现 match 函数，若 match 函数返回 true，则 match 匹配的指令将由 <code>udc_filter_t::apply</code> 替换。</p>
<p>install_microcode_filter 的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// register/unregister non-standard microcode generator</span><br><span class="hljs-comment">/// \\param filter  - microcode generator object</span><br><span class="hljs-comment">/// \\param install - TRUE - register the object, FALSE - unregister</span><br><span class="hljs-comment">/// \\return success</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> hexapi <span class="hljs-title">install_microcode_filter</span><span class="hljs-params">(<span class="hljs-keyword">microcode_filter_t</span> *filter, <span class="hljs-keyword">bool</span> install=<span class="hljs-literal">true</span>)</span></span>;<br><br></code></pre></td></tr></table></figure>

<p>最后回到用户自定义的 <code>udc_exit_t</code> 该类继承于 <code>udc_filter_t</code> 因此实现了父类中的 match 方法<br>当指令为 svc 且操作数是对应的系统调用号时返回 True，修改其指令的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">codegen_t</span>&amp; cdg)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> cdg.insn.itype == ARM_svc &amp;&amp; cdg.insn.Op1.value == code;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>初始化阶段调用 <code>init</code> 构造 call 指令对应目标函数的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> decl[MAXSTR];<br>qsnprintf(decl, <span class="hljs-keyword">sizeof</span>(decl), <span class="hljs-string">&quot;int __usercall %s@&lt;R0&gt;(int status@&lt;R1&gt;);&quot;</span>, name);<br><span class="hljs-keyword">bool</span> ok = init(decl);<br><br></code></pre></td></tr></table></figure>

<p>udc_filter_t 只需要指定函数描述以及自定义 match 函数就可实现将任意指令替换成一条 call 指令</p>
<h3 id="python-实现版本-1"><a href="#python-实现版本-1" class="headerlink" title="python 实现版本"></a>python 实现版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">class <span class="hljs-title">udc_exit_t</span><span class="hljs-params">(ida_hexrays.<span class="hljs-keyword">udc_filter_t</span>)</span>:</span><br><span class="hljs-function">    def __<span class="hljs-title">init__</span><span class="hljs-params">(self, code, name)</span>:</span><br><span class="hljs-function">        ida_hexrays.<span class="hljs-keyword">udc_filter_t</span>.__<span class="hljs-title">init__</span><span class="hljs-params">(self)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.<span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-string">&quot;int __usercall %s@&lt;R0&gt;(int status@&lt;R1&gt;);&quot;</span> % name)</span>:</span><br><span class="hljs-function">            raise <span class="hljs-title">Exception</span><span class="hljs-params">(<span class="hljs-string">&quot;Couldn&#x27;t initialize udc_exit_t instance&quot;</span>)</span></span><br><span class="hljs-function">        self.code </span>= code<br>        self.installed = False<br><br>    def match(self, cdg):<br>        <span class="hljs-keyword">return</span> cdg.insn.itype == ida_allins.ARM_svc <span class="hljs-keyword">and</span> cdg.insn.Op1.value == self.code<br><br>    def install(self):<br>        ida_hexrays.install_microcode_filter(self, True);<br>        self.installed = True<br><br>    def uninstall(self):<br>        ida_hexrays.install_microcode_filter(self, False);<br>        self.installed = False<br><br>    def toggle_install(self):<br>        <span class="hljs-keyword">if</span> self.installed:<br>            self.uninstall()<br>        <span class="hljs-keyword">else</span>:<br>            self.install()<br>udc_exit = <span class="hljs-keyword">udc_exit_t</span>(<span class="hljs-number">0x900001</span>, <span class="hljs-string">&quot;svc_exit&quot;</span>)<br>udc_exit.toggle_install()<br><br></code></pre></td></tr></table></figure>

<p>看起来 python 操作 microcode 似乎也挺方便的。</p>
<p>最后指令常量可以在 <code>allins.hpp</code> 文件中找到。</p>
<h2 id="vsd9"><a href="#vsd9" class="headerlink" title="vsd9"></a>vsd9</h2><p>生成当前函数的 microcode 并将生成结果输出在 output window</p>
<p>核心代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Generate microcode. This call returns fully optimized microcode.</span><br><span class="hljs-comment">// If desired, we could hook to decompiler events and return MERR_STOP</span><br><span class="hljs-comment">// to return microcode from previous analysis stages. Another and easier</span><br><span class="hljs-comment">// way of obtaining microcode of earlier stages is to explicitly specify</span><br><span class="hljs-comment">// the required maturity level in the gen_mircocode() call.</span><br><span class="hljs-keyword">hexrays_failure_t</span> hf;<br><span class="hljs-keyword">func_t</span> *pfn = get_func(get_screen_ea());<br><span class="hljs-keyword">mba_t</span> *mba = gen_microcode(pfn, &amp;hf, <span class="hljs-literal">NULL</span>, DECOMP_WARNINGS);<br><span class="hljs-comment">// Dump the microcode to the output window</span><br><span class="hljs-keyword">vd_printer_t</span> vp;<br>mba-&gt;print(vp);<br><span class="hljs-keyword">delete</span> mba; <span class="hljs-comment">// 需要用户清理内存</span><br><br></code></pre></td></tr></table></figure>

<p>gen_microcode  函数定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// Generate microcode of an arbitrary code snippet</span><br><span class="hljs-comment">/// \\param mbr          snippet ranges</span><br><span class="hljs-comment">/// \\param hf           extended error information (if failed)</span><br><span class="hljs-comment">/// \\param retlist      list of registers the snippet returns</span><br><span class="hljs-comment">/// \\param decomp_flags bitwise combination of \\ref DECOMP_... bits</span><br><span class="hljs-comment">/// \\param reqmat       required microcode maturity</span><br><span class="hljs-comment">/// \\return pointer to  the microcode, NULL if failed.</span><br><br><span class="hljs-function"><span class="hljs-keyword">mba_t</span> *hexapi <span class="hljs-title">gen_microcode</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">mba_ranges_t</span> &amp;mbr,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">hexrays_failure_t</span> *hf,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">mlist_t</span> *retlist=<span class="hljs-literal">NULL</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> decomp_flags=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">mba_maturity_t</span> reqmat=MMAT_GLBOPT3)</span></span>;<br><br></code></pre></td></tr></table></figure>

<p>gen_microcode 的最后一个参数可以指定 mirocode 生成的阶段，microcode 是分阶段生成的。</p>
<p>microcode maturity 枚举值如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// Microcode maturity levels</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">mba_maturity_t</span></span><br><span class="hljs-class">&#123;</span><br>  MMAT_ZERO,         <span class="hljs-comment">///&lt; microcode does not exist</span><br>  MMAT_GENERATED,    <span class="hljs-comment">///&lt; generated microcode</span><br>  MMAT_PREOPTIMIZED, <span class="hljs-comment">///&lt; preoptimized pass is complete</span><br>  MMAT_LOCOPT,       <span class="hljs-comment">///&lt; local optimization of each basic block is complete.</span><br>                     <span class="hljs-comment">///&lt; control flow graph is ready too.</span><br>  MMAT_CALLS,        <span class="hljs-comment">///&lt; detected call arguments</span><br>  MMAT_GLBOPT1,      <span class="hljs-comment">///&lt; performed the first pass of global optimization</span><br>  MMAT_GLBOPT2,      <span class="hljs-comment">///&lt; most global optimization passes are done</span><br>  MMAT_GLBOPT3,      <span class="hljs-comment">///&lt; completed all global optimization. microcode is fixed now.</span><br>  MMAT_LVARS,        <span class="hljs-comment">///&lt; allocated local variables</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>关于 vd_printer_t 的一些注释</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Notes:</span><br><span class="hljs-comment">// 1. You may derive your own class based on vd_printer_t and redirect the</span><br><span class="hljs-comment">//    output anywhere you want.</span><br><span class="hljs-comment">// 2. There is also mblock_t::print() that prints one basic block.</span><br><span class="hljs-comment">// 3. There are also mba_t::dump() and mblock_t::dump() functions</span><br><span class="hljs-comment">//    that create a file in the directory pointed by IDA_DUMPDIR environment</span><br><span class="hljs-comment">//    variable. These function work only under debugger (they are convenient</span><br><span class="hljs-comment">//    to use under debugger: dump the current microcode and study it).</span><br><span class="hljs-comment">//    The decompiler itself will dump its internal state if run under</span><br><span class="hljs-comment">//    debugger, so that all microcode transformations can be tracked.</span><br><span class="hljs-comment">// 4. Printing individual instructions with minsn_t::print() and omitting</span><br><span class="hljs-comment">//    SHINS_SHORT is supported only while decompiling the function or immediately</span><br><span class="hljs-comment">//    after it because minsn_t::print() uses a global variable that points</span><br><span class="hljs-comment">//    to the current mba_t. However, printing mblock_t and mba_t</span><br><span class="hljs-comment">//    is ok any time from the main thread. Decompiler is not thread-safe</span><br><span class="hljs-comment">//    and must be used only from the main thread.</span><br><br><span class="hljs-comment">// We must explicitly delete the microcode array</span><br><br></code></pre></td></tr></table></figure>

<h2 id="vds10"><a href="#vds10" class="headerlink" title="vds10"></a>vds10</h2><p>该插件演示了如何添加一条 microcode 优化规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*        call   !DbgRaiseAssertionFailure &lt;fast:&gt;<span class="hljs-number">.0</span><br>*      =&gt;<br>*        call   !DbgRaiseAssertionFailure &lt;fast:<span class="hljs-string">&quot;char *&quot;</span> <span class="hljs-string">&quot;assertion text&quot;</span>&gt;<span class="hljs-number">.0</span><br><br></code></pre></td></tr></table></figure>

<p>安装注册优化规则处理类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">install_optinsn_handler(&amp;nt_assert_optimizer);<br><br></code></pre></td></tr></table></figure>

<p>优化规则类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nt_assert_optimizer_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">optinsn_t</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">mblock_t</span> *, <span class="hljs-keyword">minsn_t</span> *ins, <span class="hljs-keyword">int</span> <span class="hljs-comment">/*optflags*/</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( handle_nt_assert(ins) )<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//lint -e&#123;818&#125; ins could be made const</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handle_nt_assert</span><span class="hljs-params">(<span class="hljs-keyword">minsn_t</span> *ins)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// recognize call   !DbgRaiseAssertionFailure &lt;fast:&gt;.0</span><br>        <span class="hljs-keyword">if</span> ( !ins-&gt;is_helper(<span class="hljs-string">&quot;DbgRaiseAssertionFailure&quot;</span>) )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// did we already add an argument?</span><br>        <span class="hljs-keyword">mcallinfo_t</span> &amp;fi = *ins-&gt;d.f;<br>        <span class="hljs-keyword">if</span> ( !fi.args.empty() )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// use a comment from the disassembly listing as the call argument</span><br>        qstring cmt;<br>        <span class="hljs-keyword">if</span> ( !get_cmt(&amp;cmt, ins-&gt;ea, <span class="hljs-literal">false</span>) )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// remove &quot;NT_ASSERT(&quot; to make the listing nicer</span><br>        <span class="hljs-keyword">if</span> ( strneq(cmt.begin(), <span class="hljs-string">&quot;NT_ASSERT(\\&quot;</span><span class="hljs-string">&quot;, 11) )</span><br><span class="hljs-string">            cmt.remove(0, 11);</span><br><span class="hljs-string">        if ( cmt.length() &gt; 2 &amp;&amp; streq(cmt.begin()+cmt.length()-2, &quot;</span>\\<span class="hljs-string">&quot;)&quot;</span>) )<br>            cmt.remove_last(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// all ok, transform the instruction by adding one more call argument</span><br>        <span class="hljs-keyword">mcallarg_t</span> &amp;fa = fi.args.push_back();<br>        fa.t    = mop_str;<br>        fa.cstr = cmt.extract();<br>        fa.type = <span class="hljs-keyword">tinfo_t</span>::get_stock(STI_PCCHAR); <span class="hljs-comment">// const char *</span><br>        fa.size = fa.type.get_size();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>代码有一点多，我们分开来看，该类继承于 <code>optinsn_t</code> 其定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// User defined callback to optimize individual microcode instructions</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">optinsn_t</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/// Optimize an instruction.</span><br>  <span class="hljs-comment">/// \\param blk current basic block. maybe NULL, which means that</span><br>  <span class="hljs-comment">///            the instruction must be optimized without context</span><br>  <span class="hljs-comment">/// \\param ins instruction to optimize; it is always a top-level instruction.</span><br>  <span class="hljs-comment">///            the callback may not delete the instruction but may</span><br>  <span class="hljs-comment">///            convert it into nop (see mblock_t::make_nop). to optimize</span><br>  <span class="hljs-comment">///            sub-instructions, visit them using minsn_visitor_t.</span><br>  <span class="hljs-comment">///            sub-instructions may not be converted into nop but</span><br>  <span class="hljs-comment">///            can be converted to &quot;mov x,x&quot;. for example:</span><br>  <span class="hljs-comment">///               add x,0,x =&gt; mov x,x</span><br>  <span class="hljs-comment">///            this callback may change other instructions in the block,</span><br>  <span class="hljs-comment">///            but should do this with care, e.g. to no break the</span><br>  <span class="hljs-comment">///            propagation algorithm if called with OPTI_NO_LDXOPT.</span><br>  <span class="hljs-comment">/// \\param optflags combination of \\ref OPTI_ bits</span><br>  <span class="hljs-comment">/// \\return number of changes made to the instruction.</span><br>  <span class="hljs-comment">///         if after this call the instruction&#x27;s use/def lists have changed,</span><br>  <span class="hljs-comment">///         you must mark the block level lists as dirty (see mark_lists_dirty)</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">mblock_t</span> *blk, <span class="hljs-keyword">minsn_t</span> *ins, <span class="hljs-keyword">int</span> optflags)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>使用 <code>install_optinsn_handler</code> 注册的回调都是 <code>optinsn_t</code> 的派生类。</p>
<p><code>optinsn_t</code> 的派生类应该实现 <code>func</code> 方法， ida 在优化 microcode 的时候自动调用该方法。</p>
<p><code>func</code>的 <code>ins</code> 参数传入的指令总是 top-level 指令，即最顶层的指令，callback 不允许删除该指令，但是可以替换成 nop （<code>mblock_t::make_nop</code>）。为了优化 sub-instructions , 使用 <code>minsn_visitor_t</code> 遍历子指令，子指令不能替换成 nop，可以用 mov x,x 代替。</p>
<p>返回值，返回改变指令的数量，若改变了 use/def 集合，必须将 block 标记为 dirty (见 mark_lists_dirty)</p>
<p>看注释觉得有点迷人，回到插件代码类: <code>nt_assert_optimizer_t</code></p>
<p><code>func</code> 函数中直接调用了 <code>handle_nt_assert</code> 函数，代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handle_nt_assert</span><span class="hljs-params">(<span class="hljs-keyword">minsn_t</span> *ins)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// recognize call   !DbgRaiseAssertionFailure &lt;fast:&gt;.0</span><br>    <span class="hljs-keyword">if</span> ( !ins-&gt;is_helper(<span class="hljs-string">&quot;DbgRaiseAssertionFailure&quot;</span>) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// did we already add an argument?</span><br>    <span class="hljs-keyword">mcallinfo_t</span> &amp;fi = *ins-&gt;d.f;<br>    <span class="hljs-keyword">if</span> ( !fi.args.empty() )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// use a comment from the disassembly listing as the call argument</span><br>    qstring cmt;<br>    <span class="hljs-keyword">if</span> ( !get_cmt(&amp;cmt, ins-&gt;ea, <span class="hljs-literal">false</span>) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// remove &quot;NT_ASSERT(&quot; to make the listing nicer</span><br>    <span class="hljs-keyword">if</span> ( strneq(cmt.begin(), <span class="hljs-string">&quot;NT_ASSERT(\\&quot;</span><span class="hljs-string">&quot;, 11) )</span><br><span class="hljs-string">        cmt.remove(0, 11);</span><br><span class="hljs-string">    if ( cmt.length() &gt; 2 &amp;&amp; streq(cmt.begin()+cmt.length()-2, &quot;</span>\\<span class="hljs-string">&quot;)&quot;</span>) )<br>        cmt.remove_last(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// all ok, transform the instruction by adding one more call argument</span><br>    <span class="hljs-keyword">mcallarg_t</span> &amp;fa = fi.args.push_back();<br>    fa.t    = mop_str;<br>    fa.cstr = cmt.extract();<br>    fa.type = <span class="hljs-keyword">tinfo_t</span>::get_stock(STI_PCCHAR); <span class="hljs-comment">// const char *</span><br>    fa.size = fa.type.get_size();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>TODO  注释什么鬼东西….</p>
<h2 id="vds11"><a href="#vds11" class="headerlink" title="vds11"></a>vds11</h2><p>演示添加一条跳转优化规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*         <span class="hljs-keyword">goto</span> L1     =&gt;        <span class="hljs-keyword">goto</span> L2<br>*         ...<br>*      L1:<br>*         <span class="hljs-keyword">goto</span> L2<br><br></code></pre></td></tr></table></figure>

<p>不同于 vds10， 这次继承的类是 <code>optblock_t</code> 而不是 vds10 的 <code>optinsn_t</code></p>
<p>注册安装函数是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">install_optblock_handler(&amp;goto_optimizer);<br><br></code></pre></td></tr></table></figure>

<p><code>optblock_t</code> 的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// User defined callback to optimize microcode blocks</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">optblock_t</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/// Optimize a block.</span><br>  <span class="hljs-comment">/// This function usually performs the optimizations that require analyzing</span><br>  <span class="hljs-comment">/// the entire block and/or its neighbors. For example it can recognize</span><br>  <span class="hljs-comment">/// patterns and perform conversions like:</span><br>  <span class="hljs-comment">/// b0:                                 b0:</span><br>  <span class="hljs-comment">///    ...                                 ...</span><br>  <span class="hljs-comment">///    jnz x, 0, @b2      =&gt;               jnz x, 0, @b2</span><br>  <span class="hljs-comment">/// b1:                                 b1:</span><br>  <span class="hljs-comment">///    add x, 0, y                         mov x, y</span><br>  <span class="hljs-comment">///    ...                                 ...</span><br>  <span class="hljs-comment">/// \\param blk Basic block to optimize as a whole.</span><br>  <span class="hljs-comment">/// \\return number of changes made to the block. See also mark_lists_dirty.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">mblock_t</span> *blk)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>goto_optimizer_t 的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">goto_optimizer_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">optblock_t</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">mblock_t</span> *blk)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( handle_goto_chain(blk) )<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//lint -e&#123;818&#125; ins could be made const</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">handle_goto_chain</span><span class="hljs-params">(<span class="hljs-keyword">mblock_t</span> *blk)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">minsn_t</span> *mgoto = blk-&gt;tail;<br>        <span class="hljs-keyword">if</span> ( mgoto == <span class="hljs-literal">NULL</span> || mgoto-&gt;opcode != m_goto )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">intvec_t</span> visited;<br>        <span class="hljs-keyword">int</span> t0 = mgoto-&gt;l.b;<br>        <span class="hljs-keyword">int</span> i = t0;<br>        <span class="hljs-keyword">mba_t</span> *mba = blk-&gt;mba;<br><br>        <span class="hljs-comment">// follow the goto chain</span><br>        <span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( !visited.add_unique(i) )<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// an endless loop, prefer to keep things as is</span><br>            <span class="hljs-keyword">mblock_t</span> *b = mba-&gt;get_mblock(i);<br>            <span class="hljs-comment">// skip assertion instructions and find first regular instruction</span><br>            <span class="hljs-keyword">minsn_t</span> *m2 = getf_reginsn(b-&gt;head);<br>            <span class="hljs-keyword">if</span> ( m2 == <span class="hljs-literal">NULL</span> || m2-&gt;opcode != m_goto )<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// not a goto</span><br>            i = m2-&gt;l.b;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( i == t0 )<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// not a chain</span><br><br>        <span class="hljs-comment">// all ok, found a goto chain</span><br>        mgoto-&gt;l.b = i; <span class="hljs-comment">// jump directly to the end of the chain</span><br><br>        <span class="hljs-comment">// fix the successor/predecessor lists</span><br>        blk-&gt;succset[<span class="hljs-number">0</span>] = i;<br>        mba-&gt;get_mblock(i)-&gt;predset.add(blk-&gt;serial);<br>        mba-&gt;get_mblock(t0)-&gt;predset.del(blk-&gt;serial);<br><br>        <span class="hljs-comment">// since we changed the control flow graph, invalidate the use/def chains.</span><br>        <span class="hljs-comment">// stricly speaking it is not really necessary in our plugin because</span><br>        <span class="hljs-comment">// we did not move around any microcode operands.</span><br>        mba-&gt;mark_chains_dirty();<br><br>        <span class="hljs-comment">// it is a good idea to verify microcode after each change</span><br>        <span class="hljs-comment">// however, it may be time consuming, so comment it out eventually</span><br>        mba-&gt;verify(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>逻辑比较简单，判断基本块结尾的指令是否为 goto 指令，并使用循环判断其目标基本块的第一条指令是否为 goto 指令。<br>这段代码展示的 goto 指令的修改，不仅要修改 goto 指令，还需修改 successor/predecessor 。</p>
<h2 id="vds12"><a href="#vds12" class="headerlink" title="vds12"></a>vds12</h2><p>这个插件可以显示对指定寄存器的所有直接引用。<br>这个看似简单的插件实际上非常复杂，演示了如何使用 microcode 的 ud / du 链相关的 API</p>
<p>寄存器交叉引用整体思路:</p>
<ol>
<li>get_screen_ea &amp; get_func 获取 EA 与当前函数</li>
<li>get_flags &amp; is_code 判断当前选中的是否为指令</li>
<li>get_current_operand 获取用户选中的操作数寄存器</li>
<li>gen_microcode, MMAT_PREOPTIMIZED 阶段，物理寄存器信息保留比较完整</li>
<li>mba_t::build_graph(), MMAT_PREOPTIMIZED 阶段要求手动调用分析 CFG</li>
<li>mba_t::analyze_calls(), MMAT_PREOPTIMIZED 阶段要求手动调用分析函数调用</li>
<li>gco_info_t::append_to_list 把用户选中的寄存器转成 mlist_t （因为后面的 API 要求 mlist_t）</li>
<li>mba_t::find_mop 找到 mlist_t 中寄存器对应的 mop_t 以及上下文信息(ctx)</li>
<li>获取 ud 与 du 链</li>
<li>根据选中寄存器 use/def 情况调用 collect_xrefs</li>
</ol>
<p>collect_xrefs 流程大概是:</p>
<ol>
<li>调用 collect_block_xrefs 收集当前基本块的 xref</li>
<li>遍历 ud / du 分析其它基本块的 xref</li>
</ol>
<p>将用户选中的寄存器有两种情况:</p>
<ol>
<li>引用 use</li>
<li>定值 def</li>
</ol>
<p>为了实现寄存器的直接交叉引用,<br>若选中寄存器是引用， 则可以通过 ud 链获取所有可以到达该引用的定值；<br>若选中寄存器是定值， 则可以通过 du 链获取该定值能到达的所有引用指令。</p>
<p>汇编语言中，有许多指令的第一个操作数，既是定值，也是引用，我们可以依次进行交叉引用分析。</p>
<p>为什么生成 MMAT_PREOPTIMIZED 阶段的 microcode 呢？ 因为这个阶段的寄存器信息保留比较完整！<br>其后分析寄存器交叉引用需要用到 ud / du 链，而它们需要 microcode 生成 CFG 并完成函数调用的分析才能够使用，但是在 MMAT_PREOPTIMIZED 阶段并没有 CFG 与 Call 分析，所以要手动调用相关函数进行分析。</p>
<h3 id="1-get-screen-ea-amp-get-func-获取-EA-与当前函数"><a href="#1-get-screen-ea-amp-get-func-获取-EA-与当前函数" class="headerlink" title="1. get_screen_ea &amp; get_func 获取 EA 与当前函数"></a>1. get_screen_ea &amp; get_func 获取 EA 与当前函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">ea_t</span> ea = get_screen_ea();<br><span class="hljs-keyword">func_t</span>* pfn = get_func(ea);<br><br></code></pre></td></tr></table></figure>

<h3 id="2-get-flags-amp-is-code-判断当前选中的是否为指令"><a href="#2-get-flags-amp-is-code-判断当前选中的是否为指令" class="headerlink" title="2. get_flags &amp; is_code 判断当前选中的是否为指令"></a>2. get_flags &amp; is_code 判断当前选中的是否为指令</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">flags_t</span> F = get_flags(ea);<br><span class="hljs-keyword">if</span> (!is_code(F)) &#123;.....&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="3-get-current-operand-获取用户选中的操作数寄存器"><a href="#3-get-current-operand-获取用户选中的操作数寄存器" class="headerlink" title="3. get_current_operand 获取用户选中的操作数寄存器"></a>3. get_current_operand 获取用户选中的操作数寄存器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">gco_info_t</span> gco;<br>get_current_operand(&amp;gco);<br><br></code></pre></td></tr></table></figure>

<h3 id="4-gen-microcode-MMAT-PREOPTIMIZED-阶段，物理寄存器信息保留比较完整"><a href="#4-gen-microcode-MMAT-PREOPTIMIZED-阶段，物理寄存器信息保留比较完整" class="headerlink" title="4. gen_microcode, MMAT_PREOPTIMIZED 阶段，物理寄存器信息保留比较完整"></a>4. gen_microcode, MMAT_PREOPTIMIZED 阶段，物理寄存器信息保留比较完整</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// generate microcode</span><br><span class="hljs-keyword">hexrays_failure_t</span> hf;<br><span class="hljs-function"><span class="hljs-keyword">mba_ranges_t</span> <span class="hljs-title">mbr</span><span class="hljs-params">(pfn)</span></span>;<br><span class="hljs-keyword">mba_t</span>* mba = gen_microcode(mbr, &amp;hf, <span class="hljs-literal">NULL</span>, DECOMP_WARNINGS, MMAT_PREOPTIMIZED);<br><br></code></pre></td></tr></table></figure>

<h3 id="5-mba-t-build-graph-MMAT-PREOPTIMIZED-阶段要求手动调用分析-CFG"><a href="#5-mba-t-build-graph-MMAT-PREOPTIMIZED-阶段要求手动调用分析-CFG" class="headerlink" title="5. mba_t::build_graph(), MMAT_PREOPTIMIZED 阶段要求手动调用分析 CFG"></a>5. mba_t::build_graph(), MMAT_PREOPTIMIZED 阶段要求手动调用分析 CFG</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">merror_t</span> merr = mba-&gt;build_graph();<br><br></code></pre></td></tr></table></figure>

<h3 id="7-gco-info-t-append-to-list-把用户选中的寄存器转成-mlist-t-（因为后面的-API-要求-mlist-t）"><a href="#7-gco-info-t-append-to-list-把用户选中的寄存器转成-mlist-t-（因为后面的-API-要求-mlist-t）" class="headerlink" title="7. gco_info_t::append_to_list 把用户选中的寄存器转成 mlist_t （因为后面的 API 要求 mlist_t）"></a>7. gco_info_t::append_to_list 把用户选中的寄存器转成 mlist_t （因为后面的 API 要求 mlist_t）</h3><p>这一步是非常迷惑的操作, 先看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// prepare mlist for the current operand. we will use to to find references</span><br><span class="hljs-comment">// to the current operand in the microcode. usually we do not use operands</span><br><span class="hljs-comment">// (processor instruction operands nor microcode instruction operands)</span><br><span class="hljs-comment">// for searches. instead, we build a &#x27;mlist_t&#x27; instance and use it.</span><br><span class="hljs-keyword">mlist_t</span> <span class="hljs-built_in">list</span>;<br><span class="hljs-keyword">if</span> (!gco.append_to_list(&amp;<span class="hljs-built_in">list</span>, mba))<br>&#123;<br>    warning(<span class="hljs-string">&quot;Failed to represent %s as microcode list&quot;</span>, gco.name.c_str());<br>    <span class="hljs-keyword">delete</span> mba;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//  list 中只有选中的寄存器对应的 micro 寄存器，例如 eax.4</span><br><br></code></pre></td></tr></table></figure>

<p>注释写得很清楚，就是说后面查找 mop 的时候用的是 mlist_t。另外 mlist_t::print 函数，可以将 mlist 中的寄存器/内存信息 dump 成文本方便调试。</p>
<p>gco 的类型是 <code>gco_info_t</code> 是一个与用户界面UI相关的类, 用来表示用户选中的寄存器, 用户选中的寄存器经过三步转换才能得到详细准确的寄存器与对应的指令等信息。<br>从数据结构来看大概是这样的: gco_info_t -&gt; mlist_t -&gt; mop_t, op_parent_info_t</p>
<h3 id="8-mba-t-find-mop-找到-mlist-t-中寄存器对应的-mop-t-以及上下文信息-ctx"><a href="#8-mba-t-find-mop-找到-mlist-t-中寄存器对应的-mop-t-以及上下文信息-ctx" class="headerlink" title="8. mba_t::find_mop 找到 mlist_t 中寄存器对应的 mop_t 以及上下文信息(ctx)"></a>8. mba_t::find_mop 找到 mlist_t 中寄存器对应的 mop_t 以及上下文信息(ctx)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">op_parent_info_t</span> ctx;<br><span class="hljs-keyword">mop_t</span>* mop = mba-&gt;find_mop(&amp;ctx, ea, gco.is_def(), <span class="hljs-built_in">list</span>);<br><br></code></pre></td></tr></table></figure>

<p><code>op_parent_info_t</code> 包含了操作数对应的上下文信息，例如对应的 Top-level 指令。</p>
<h3 id="9-获取-ud-与-du-链"><a href="#9-获取-ud-与-du-链" class="headerlink" title="9. 获取 ud 与 du 链"></a>9. 获取 ud 与 du 链</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-comment">// get use-def chains. do it inside a block in order to release</span><br>    <span class="hljs-comment">// the chains immediately after using them</span><br>    <span class="hljs-keyword">mbl_graph_t</span>* graph = mba-&gt;get_graph();<br>    <span class="hljs-keyword">chain_keeper_t</span> ud = graph-&gt;get_ud(GC_REGS_AND_STKVARS);<br>    <span class="hljs-keyword">chain_keeper_t</span> du = graph-&gt;get_du(GC_REGS_AND_STKVARS);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>mbl_graph_t *</code> 会在基本块退出时自动释放。</p>
<h3 id="10-根据选中寄存器-use-def-情况调用-collect-xrefs"><a href="#10-根据选中寄存器-use-def-情况调用-collect-xrefs" class="headerlink" title="10. 根据选中寄存器 use/def 情况调用 collect_xrefs"></a>10. 根据选中寄存器 use/def 情况调用 collect_xrefs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (gco.is_use())<br>&#123;<br>    <span class="hljs-comment">// collect definitions</span><br>    collect_xrefs(&amp;xrefs, ctx, mop, <span class="hljs-built_in">list</span>, ud, <span class="hljs-literal">false</span>);<br>    ndefs = xrefs.size();<br>    <span class="hljs-comment">// register is used by the current instruction - add &#x27;ea&#x27; as use-addr</span><br>    xrefs.add_unique(ea);<br>&#125;<br><br><span class="hljs-keyword">if</span> (gco.is_def())<br>&#123;<br>    <span class="hljs-comment">// register is defined by the current instruction - add &#x27;ea&#x27; as def-addr</span><br>    <span class="hljs-keyword">if</span> (xrefs.add_unique(ea))<br>        ndefs = xrefs.size();<br>    <span class="hljs-comment">// collect using</span><br>    collect_xrefs(&amp;xrefs, ctx, mop, <span class="hljs-built_in">list</span>, du, <span class="hljs-literal">true</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如果选中的寄存器是 use 则使用 ud 去调用 <code>collect_xrefs</code> 且最后一个参数 find_uses = true<br>如果选中的寄存器是 def 则使用 du 去调用 <code>collect_xrefs</code> 且最后一个参数 find_uses = false<br>find_uses 决定的是基本块内搜索的方向。</p>
<h3 id="collect-xrefs-分析"><a href="#collect-xrefs-分析" class="headerlink" title="collect_xrefs 分析"></a>collect_xrefs 分析</h3><p>collect_xrefs 主要的作用是调用 <code>collect_block_xrefs</code> 函数收集基本块内的交叉引用信息, 先收集当前基本块的交叉引用，再通过 du 链查找其它 use 或 def 基本块，并收集其信息。<br>ud/du 链中只存储了use或def的基本块信息，没有具体到某一条指令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collect_xrefs</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">eavec_t</span>* out,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">op_parent_info_t</span>&amp; ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mop_t</span>* mop,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">mlist_t</span> <span class="hljs-built_in">list</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">graph_chains_t</span>&amp; du,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> find_uses)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// first collect the references in the current block</span><br>    <span class="hljs-keyword">minsn_t</span>* start = find_uses ? ctx.topins-&gt;next : ctx.topins-&gt;prev;<br>    collect_block_xrefs(out, &amp;<span class="hljs-built_in">list</span>, ctx.blk, start, find_uses);<br><br>    <span class="hljs-comment">// then find references in other blocks</span><br>    <span class="hljs-keyword">int</span> serial = ctx.blk-&gt;serial;                 <span class="hljs-comment">// block number of the operand</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">block_chains_t</span>&amp; bc = du[serial];        <span class="hljs-comment">// chains of that block</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">chain_t</span>* ch = bc.get_chain(*mop);       <span class="hljs-comment">// chain of the operand</span><br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// odd</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ch-&gt;size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> bn = ch-&gt;at(i);<br>        <span class="hljs-keyword">mblock_t</span>* b = ctx.mba-&gt;get_mblock(bn);      <span class="hljs-comment">// block that uses the instruction</span><br>        <span class="hljs-keyword">minsn_t</span>* ins = find_uses ? b-&gt;head : b-&gt;tail;<br>        <span class="hljs-keyword">mlist_t</span> tmp = <span class="hljs-built_in">list</span>; <span class="hljs-comment">// 注意这里每次循环都重新赋值，不是传址</span><br>        collect_block_xrefs(out, &amp;tmp, b, ins, find_uses);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>从这段代码我们可以窥探 IDA 的 du/ud 链条的设计， IDA 用 <code>graph_chains_t</code> 数据类型来表示整个函数的du/ud 链，它其实是一个 vector 存储的是 <code>block_chains_t</code> 其下标与基本块的 serial 相对应。<br><code>block_chains_t</code> 是一个 map 结构，将基本块内的所有 mop 操作数与对应的 ud/du 链关联。<br><code>chain_keeper_t</code> 其实是一个三级结构，第一级由基本块下标索引，第二级由操作数索引，第三级才是操作数对应的 du 链。</p>
<p>总结一下，我们如果想获取某个基本块中某个操作数的 du 链条:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">mbl_graph_t</span>* graph = mba-&gt;get_graph();<br><span class="hljs-keyword">chain_keeper_t</span> du = graph-&gt;get_du(GC_REGS_AND_STKVARS); <span class="hljs-comment">// 函数所有的du链</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">block_chains_t</span>&amp; bc = du[serial]; <span class="hljs-comment">// 索引到具体的基本块</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">chain_t</span>* ch = bc.get_chain(*mop); <span class="hljs-comment">// 索引到具体的操作数</span><br><br></code></pre></td></tr></table></figure>

<p>操作数对应的 du 链条中存储的是 use 该操作数的其它基本块的下标， 而不是具体的指令表示。<code>collect_block_xrefs</code> 函数的功能就是收集基本块内的 use/def 信息</p>
<h3 id="collect-block-xrefs-分析"><a href="#collect-block-xrefs-分析" class="headerlink" title="collect_block_xrefs 分析"></a>collect_block_xrefs 分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collect_block_xrefs</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">eavec_t</span>* out,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">mlist_t</span>* <span class="hljs-built_in">list</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mblock_t</span>* blk,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* ins,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> find_uses)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* p = ins;<br>        p != <span class="hljs-literal">NULL</span> &amp;&amp; !<span class="hljs-built_in">list</span>-&gt;empty();<br>        p = find_uses ? p-&gt;next : p-&gt;prev)<br>    &#123;<br>        <span class="hljs-keyword">mlist_t</span> use = blk-&gt;build_use_list(*p, MUST_ACCESS); <span class="hljs-comment">// things used by the insn</span><br>        <span class="hljs-keyword">mlist_t</span> def = blk-&gt;build_def_list(*p, MUST_ACCESS); <span class="hljs-comment">// things defined by the insn</span><br>        <span class="hljs-keyword">mlist_t</span>&amp; plst = find_uses ? use : def;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;has_common(plst))<br>            out-&gt;add_unique(p-&gt;ea); <span class="hljs-comment">// this microinstruction seems to use our operand</span><br>        <span class="hljs-built_in">list</span>-&gt;sub(def);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>首先要讲的就是 <code>find_uses</code> 的作用，字面意思很好理解，就是是否搜索引用还是搜索定值，其实区别主要还是在于搜索方向的不同。</p>
<p>搜索 use 的方向是从第一条指令开始，向后搜索，遇到对这条指令的 def 则退出搜索。<br>搜索 def 的方向是从最后一条指令开始，向前搜索，遇到对这条指令的 def 则退出搜索。</p>
<p>根据数据流分析理论，def 可以 kill 掉变量的活跃性。因此，我们可以说，搜索 use 的时候正向遍历，遇到 def 的时候退出。 搜索 def 的时候反向遍历，遇到 def 的时候退出。</p>
<p><code>mlist_t</code> 设计真的非常好，寄存器用的是 BitVector 存储，支持快速位运算，做数据流算法的时候非常高效。</p>
<p>我们主要来看一下循环，循环根据 find_uses 方向遍历指令（向前/向后），并且 list 不为空才会继续遍历。<br>循环内部先获取了当前指令的 use/def，并通过 has_common 判断是否与当前搜索的操作数是否有交集，如果有交集则直接将指令的地址加入到结果列表。</p>
<p>从 list 中删除 def 的寄存器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">list</span>-&gt;sub(def)<br></code></pre></td></tr></table></figure>

<p>list 中其实就只有待搜索的一个寄存器，若该寄存器被 def 就会从list删除，循环也会因此退出。</p>
<h3 id="其它交叉引用-UI-部分"><a href="#其它交叉引用-UI-部分" class="headerlink" title="其它交叉引用 UI 部分"></a>其它交叉引用 UI 部分</h3><p>UI 部分的代码分析我就不写了，比较简单，可以自行查看。</p>
<h2 id="vds13"><a href="#vds13" class="headerlink" title="vds13"></a>vds13</h2><p>这个插件生成选中的代码并输出 microcode</p>
<p>核心代码非常简单</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// generate microcode</span><br><span class="hljs-keyword">hexrays_failure_t</span> hf;<br><span class="hljs-keyword">mba_ranges_t</span> mbr;<br>mbr.ranges.push_back(<span class="hljs-keyword">range_t</span>(ea1, ea2));<br><span class="hljs-keyword">mba_t</span> *mba = gen_microcode(mbr, &amp;hf, <span class="hljs-literal">NULL</span>, DECOMP_WARNINGS);<br><span class="hljs-keyword">if</span> ( mba == <span class="hljs-literal">NULL</span> )<br>&#123;<br>    warning(<span class="hljs-string">&quot;%a: %s&quot;</span>, hf.errea, hf.desc().c_str());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>msg(<span class="hljs-string">&quot;Successfully generated microcode for %a..%a\\n&quot;</span>, ea1, ea2);<br><span class="hljs-keyword">vd_printer_t</span> vp;<br>mba-&gt;<span class="hljs-built_in">print</span>(vp);<br><br><span class="hljs-comment">// We must explicitly delete the microcode array</span><br><span class="hljs-keyword">delete</span> mba;<br><br></code></pre></td></tr></table></figure>

<p>主要演示了 <code>mba_ranges_t</code> 的构造。</p>
<h2 id="vds14"><a href="#vds14" class="headerlink" title="vds14"></a>vds14</h2><p>略</p>
<h2 id="vds15"><a href="#vds15" class="headerlink" title="vds15"></a>vds15</h2><p>演示使用 <code>get_valranges()</code> 获取寄存器的值域.</p>
<p>这个插件也受到诸多的限制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*      Unfortunately <span class="hljs-keyword">this</span> plugin is of limited use because:<br>*        - simple cases where a single value is assigned to a <span class="hljs-keyword">register</span><br>*          are automatically handled by the decompiler <span class="hljs-keyword">and</span> the <span class="hljs-keyword">register</span><br>*          is replaced by the value<br>*        - too <span class="hljs-built_in">complex</span> cases where the <span class="hljs-keyword">register</span> gets its value from untrackable<br>*          sources, it fails<br>*        - only value ranges at the basic block start are shown<br><br></code></pre></td></tr></table></figure>

<p>主要核心代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> idaapi <span class="hljs-title">plugin_ctx_t::run</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">ea_t</span> ea = get_screen_ea();<br>    <span class="hljs-keyword">func_t</span>* pfn = get_func(ea);<br>    <span class="hljs-keyword">if</span> (pfn == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        msg(<span class="hljs-string">&quot;Please position the cursor within a function\\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">flags_t</span> F = get_flags(ea);<br>    <span class="hljs-keyword">if</span> (!is_code(F))<br>    &#123;<br>        msg(<span class="hljs-string">&quot;Please position the cursor on an instruction\\n\\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">gco_info_t</span> gco;<br>    <span class="hljs-keyword">if</span> (!get_current_operand(&amp;gco))<br>    &#123;<br>        msg(<span class="hljs-string">&quot;Could not find a register or stkvar in the current operand\\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// generate microcode</span><br>    <span class="hljs-keyword">hexrays_failure_t</span> hf;<br>    <span class="hljs-function"><span class="hljs-keyword">mba_ranges_t</span> <span class="hljs-title">mbr</span><span class="hljs-params">(pfn)</span></span>;<br>    <span class="hljs-keyword">mba_t</span>* mba = gen_microcode(mbr, &amp;hf, <span class="hljs-literal">NULL</span>, DECOMP_WARNINGS);<br>    <span class="hljs-keyword">if</span> (mba == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        msg(<span class="hljs-string">&quot;%a: %s\\n&quot;</span>, hf.errea, hf.desc().c_str());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// prepare mlist for the current operand</span><br>    <span class="hljs-keyword">mlist_t</span> <span class="hljs-built_in">list</span>;<br>    <span class="hljs-keyword">if</span> (!gco.append_to_list(&amp;<span class="hljs-built_in">list</span>, mba))<br>    &#123;<br>        msg(<span class="hljs-string">&quot;Failed to represent %s as microcode list\\n&quot;</span>, gco.name.c_str());<br>        <span class="hljs-keyword">delete</span> mba;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// find micro-insn nearest to EA</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mblock_t</span>* b;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* ins;<br>    <span class="hljs-keyword">if</span> (!find_insn_with_list(&amp;b, &amp;ins, mba, ea, <span class="hljs-built_in">list</span>, gco.is_def()))<br>    &#123;<br>        msg(<span class="hljs-string">&quot;Could not find %s after %a in the microcode, sorry\\n&quot;</span><br>            <span class="hljs-string">&quot;Probably it has been optimized away\\n&quot;</span>,<br>            gco.name.c_str(), ea);<br>        <span class="hljs-keyword">delete</span> mba;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">valrng_t</span> vr;<br>    <span class="hljs-keyword">int</span> vrflags = VR_AT_START | VR_EXACT;<br>    <span class="hljs-keyword">if</span> (b-&gt;get_valranges(&amp;vr, gco.cvt_to_ivl(), ins, vrflags))<br>    &#123;<br>        qstring vrstr;<br>        vr.print(&amp;vrstr);<br>        msg(<span class="hljs-string">&quot;Value ranges of %s at %a: %s\\n&quot;</span>,<br>            gco.name.c_str(),<br>            ins-&gt;ea,<br>            vrstr.c_str());<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        msg(<span class="hljs-string">&quot;Cannot find value ranges of %s\\n&quot;</span>, gco.name.c_str());<br>    &#125;<br><br>    <span class="hljs-comment">// We must explicitly delete the microcode array</span><br>    <span class="hljs-keyword">delete</span> mba;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>find_insn_with_list</code> 函数的功能是寻找指定含有选中 opcode 最接近 EA 的顶级指令，待会儿我们来分析这个函数。<br>我们来看看 <code>get_valranges</code> 的调用<br>函数原型: <code>bool get_valranges(valrng_t valrng, vivl_t vivl, minsn_t minsn, int VRFLAGS)</code><br>第一个参数 <code>valrng</code>: 输出结果, 用于表示值域<br>第二个参数 <code>vivl</code>  : 输入, 用于表示搜索的对象 <code>gco.cvt_to_ivl()</code> 转换<br>第三个参数 <code>minsn</code> : 输入, 搜索的目标指令<br>第四个参数 <code>VRFLAGS</code>: 标志信息, 宏以 <code>VR_</code> 开头</p>
<p><code>VR_</code> 开头的宏主要有三个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VR_AT_START 0x0000    <span class="hljs-comment">///&lt; get value ranges before the instruction or</span></span><br>                              <span class="hljs-comment">///&lt; at the block start (if M is NULL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VR_AT_END   0x0001    <span class="hljs-comment">///&lt; get value ranges after the instruction or</span></span><br>                              <span class="hljs-comment">///&lt; at the block end, just after the last</span><br>                              <span class="hljs-comment">///&lt; instruction (if M is NULL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VR_EXACT    0x0002    <span class="hljs-comment">///&lt; find exact match. if not set, the returned</span></span><br>                              <span class="hljs-comment">///&lt; valrng size will be &gt;= vivl.size</span><br><br></code></pre></td></tr></table></figure>

<p>具体调用代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">valrng_t</span> vr;<br><span class="hljs-keyword">int</span> vrflags = VR_AT_START | VR_EXACT;<br><span class="hljs-keyword">if</span> (b-&gt;get_valranges(&amp;vr, gco.cvt_to_ivl(), ins, vrflags))<br>&#123;<br>    qstring vrstr;<br>    vr.print(&amp;vrstr);<br>    msg(<span class="hljs-string">&quot;Value ranges of %s at %a: %s\\n&quot;</span>,<br>        gco.name.c_str(),<br>        ins-&gt;ea,<br>        vrstr.c_str());<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="find-insn-with-list-分析"><a href="#find-insn-with-list-分析" class="headerlink" title="find_insn_with_list 分析"></a>find_insn_with_list 分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// find the first top micro-instruction after EA that uses or defines LIST</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">find_insn_with_list</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mblock_t</span>** blk,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>** ins,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">mba_t</span>* mba,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">ea_t</span> _ea,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mlist_t</span>&amp; _list,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> _is_dest)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ida_local</span> <span class="hljs-title">top_visitor_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">minsn_visitor_t</span><br>    &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">mblock_t</span>* b = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* ins = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">ea_t</span> ea;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">mlist_t</span>&amp; <span class="hljs-built_in">list</span>;<br>        <span class="hljs-keyword">bool</span> is_dest;<br>        <span class="hljs-keyword">top_visitor_t</span>(<span class="hljs-keyword">ea_t</span> e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">mlist_t</span>&amp; l, <span class="hljs-keyword">bool</span> d) : ea(e), <span class="hljs-built_in">list</span>(l), is_dest(d) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_minsn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (topins-&gt;ea == ea) <span class="hljs-comment">// 当前指令刚好与目标 ea 匹配</span><br>            &#123;<br>                <span class="hljs-comment">// exact match</span><br>                b = blk; <span class="hljs-comment">// The context info used by visitors</span><br>                ins = topins;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (blk-&gt;start &lt;= ea &amp;&amp; topins-&gt;ea &gt; ea) <span class="hljs-comment">// blk-start &lt;= ea &lt; topIns-&gt;ea</span><br>            &#123;<br>                <span class="hljs-keyword">mlist_t</span> defuse = is_dest<br>                    ? blk-&gt;build_def_list(*topins, MUST_ACCESS)<br>                    : blk-&gt;build_use_list(*topins, MUST_ACCESS);<br>                <span class="hljs-keyword">if</span> (defuse.has_common(<span class="hljs-built_in">list</span>)<br>                    &amp;&amp; (ins == <span class="hljs-literal">nullptr</span> || topins-&gt;ea &lt; ins-&gt;ea))<br>                &#123;<br>                    <span class="hljs-comment">// nearest use/def to EA</span><br>                    b = blk;<br>                    ins = topins;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">top_visitor_t</span> <span class="hljs-title">tv</span><span class="hljs-params">(_ea, _list, _is_dest)</span></span>;<br><br>    mba-&gt;for_all_topinsns(tv); <span class="hljs-comment">//遍历所有的 top-level 指令</span><br>    <span class="hljs-keyword">if</span> (tv.ins != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        *blk = tv.b;<br>        *ins = tv.ins;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码很简单就不过多解释了，唯一需要注意的是 <code>minsn_visitor_t</code> 继承于 <code>op_parent_info_t</code><br>所以在实现的观察者类中可以直接用 <code>op_parent_info_t</code> 中的 <code>blk</code>， 而非参数中的 <code>blk</code>.</p>
<h2 id="vds16"><a href="#vds16" class="headerlink" title="vds16"></a>vds16</h2><p>添加一个常规的指令优化规则插件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*        mov #N, var<span class="hljs-number">.4</span>                  mov #N, var<span class="hljs-number">.4</span><br>*        <span class="hljs-keyword">xor</span> var@<span class="hljs-number">1.1</span>, #M, var@<span class="hljs-number">1.1</span>    =&gt; mov #NM, var@<span class="hljs-number">1.1</span><br>*                                         where NM == (N&gt;&gt;<span class="hljs-number">8</span>)^M<br>*<br>*      We need <span class="hljs-keyword">this</span> rule because the decompiler cannot propagate the second<br>*      byte of VAR into the <span class="hljs-keyword">xor</span> instruction.<br>*<br>*      The XOR opcode can be replaced by any other, we <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> rely on it.<br>*      Also operand sizes can vary.<br><br></code></pre></td></tr></table></figure>

<p>说实话，没有看懂这个优化具体是干什么的, 部分分析看注释吧。<br>优化的主要代码如下: func</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//--------------------------------------------------------------------------</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">glbprop_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">optinsn_t</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">mblock_t</span>* blk, <span class="hljs-keyword">minsn_t</span>* ins, <span class="hljs-keyword">int</span> <span class="hljs-comment">/*optflags*/</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (ins-&gt;r.t != mop_n) <span class="hljs-comment">// 判断第二个操作数必须为常数 xor var@1.1, #M, var@1.1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// we want a constant as the second operand</span><br><br>        <span class="hljs-keyword">if</span> (ins-&gt;r.size &gt; <span class="hljs-number">2</span>) <span class="hljs-comment">// 只有长度为1时，decompiler 无法处理</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// bigger sizes are handled by the decompiler without problems</span><br><br>          <span class="hljs-comment">// build list of data used by INS</span><br>        <span class="hljs-keyword">mlist_t</span> use = blk-&gt;build_use_list(*ins, MAY_ACCESS);<br><br>        <span class="hljs-comment">// find the instruction that defines anything from USE</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* di = find_prev_def(blk, use, ins); <span class="hljs-comment">// 寻找对当前操作数的定值指令</span><br>        <span class="hljs-keyword">if</span> (di == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// not found</span><br><br>        <span class="hljs-keyword">if</span> (di-&gt;opcode != m_mov || di-&gt;l.t != mop_n)<span class="hljs-comment">// 判断定值指令的第一个操作数是否为立即数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// must be &#x27;mov #N, ...&#x27;</span><br><br>          <span class="hljs-comment">// compare the destination of DI and the left operand of INS</span><br>        <span class="hljs-keyword">mop_t</span> v1 = ins-&gt;l;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">mop_t</span>&amp; v2 = di-&gt;d;<br>        <span class="hljs-keyword">if</span> (v1.t != v2.t)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// operand types are different</span><br><br>          <span class="hljs-comment">// if operand sizes are the same, hexrays can handle it without our help</span><br>          <span class="hljs-comment">// if the size of INS-&gt;L is bigger than the size of DI-&gt;D, may not propagate</span><br>          <span class="hljs-comment">// we handle only the case where the size of INS-&gt;L is less than the size</span><br>          <span class="hljs-comment">// of DI-&gt;D because the hexrays sometimes has problems with it.</span><br>        <span class="hljs-keyword">if</span> (v1.size &gt;= v2.size)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// this is not very efficient... but acceptable</span><br>        <span class="hljs-keyword">int</span> off = <span class="hljs-number">0</span>;<span class="hljs-comment">//v1 -&gt; var@1.1  不是很理解这个循环在寻找什么东西？</span><br>        <span class="hljs-keyword">while</span> (!v1.equal_mops(v2, EQ_IGNSIZE)) <span class="hljs-comment">// EQ_IGNSIZE:ignore source operand sizes</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (++off &gt;= v2.size)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (!v1.shift_mop(<span class="hljs-number">-1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// found a match! shift N in order to propagate the correct part of it</span><br>        <span class="hljs-comment">// we don&#x27;t truncate the high bits, it will happen in make_number()</span><br>        uint64 N = di-&gt;l.value(<span class="hljs-literal">false</span>);<br>        N &gt;&gt;= (off * <span class="hljs-number">8</span>);<br><br>        <span class="hljs-comment">// store the new value in INS</span><br>        ins-&gt;l.make_number(N, ins-&gt;l.size, di-&gt;l.nnn-&gt;ea, di-&gt;l.nnn-&gt;opnum);<br><br>        <span class="hljs-comment">// optimize the instruction, it is highly likely that we will get</span><br>        <span class="hljs-comment">// a much simpler instruction like &#x27;mov&#x27;</span><br>        ins-&gt;optimize_solo();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// success, we made one change</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>向前（低地址）寻找引用的定值指令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">// find backwards the instruction that defines anything from LST</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* <span class="hljs-title">find_prev_def</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mblock_t</span>* blk,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">mlist_t</span>&amp; lst,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* ins)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">minsn_t</span>* p = ins;<br>    <span class="hljs-keyword">while</span> ((p = p-&gt;prev) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">mlist_t</span> def = blk-&gt;build_def_list(*p, MAY_ACCESS | FULL_XDSU);<br>        <span class="hljs-keyword">if</span> (def.has_common(lst))<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="vds18"><a href="#vds18" class="headerlink" title="vds18"></a>vds18</h2><p>这个插件展示了如何给指定位置的指定寄存器指定一个值，这个功能在一些混淆场景中非常有用。</p>
<p>插件入口函数代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//--------------------------------------------------------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> idaapi <span class="hljs-title">plugin_ctx_t::run</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Currently the user can only add new regvals. Since the main goal of</span><br>    <span class="hljs-comment">// this plugin to illustrate how to modify the microcode, deleting or showing</span><br>    <span class="hljs-comment">// fixed regvals is left as an exercise to the reader.</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> form[] =<br>        <span class="hljs-string">&quot;Specify known register value\\n&quot;</span><br>        <span class="hljs-string">&quot;&lt;~A~ddress :$::16::&gt;\\n&quot;</span><br>        <span class="hljs-string">&quot;&lt;~R~egister:q::16::&gt;\\n&quot;</span><br>        <span class="hljs-string">&quot;&lt;~V~alue   :L::16::&gt;\\n&quot;</span><br>        <span class="hljs-string">&quot;\\n&quot;</span>;<br>    <span class="hljs-keyword">static</span> qstring regname;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">fixed_regval_info_t</span> fri;<br>    CASSERT(<span class="hljs-keyword">sizeof</span>(fri.ea) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">ea_t</span>));<br>    CASSERT(<span class="hljs-keyword">sizeof</span>(fri.value) == <span class="hljs-keyword">sizeof</span>(uint64));<br>    <span class="hljs-keyword">while</span> (ask_form(form, &amp;fri.ea, &amp;regname, &amp;fri.value))<br>    &#123;<br>        <span class="hljs-keyword">reg_info_t</span> ri;<br>        <span class="hljs-keyword">if</span> (!parse_reg_name(&amp;ri, regname.c_str()))<br>        &#123;<br>            warning(<span class="hljs-string">&quot;Sorry, bad register name: %s&quot;</span>, regname.c_str());<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        fri.nbytes = ri.size;<br>        fri.reg = reg2mreg(ri.reg);<br>        <span class="hljs-keyword">if</span> (fri.reg == mr_none)<br>        &#123;<br>            warning(<span class="hljs-string">&quot;Failed to convert to microregister: %s&quot;</span>, regname.c_str());<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// apparently this register is not supported by the decompiler</span><br>        &#125;<br>        <span class="hljs-keyword">bool</span> found = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; rv : user_regvals)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (rv.ea == fri.ea &amp;&amp; rv.reg == fri.reg)<br>            &#123;<br>                rv.nbytes = fri.nbytes;<br>                rv.value = fri.value;<br>                found = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!found)<br>            user_regvals.push_back(fri);<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> fmt[] = <span class="hljs-string">&quot;Register %s at %a is considered to be equal to 0x%&quot;</span> FMT_64 <span class="hljs-string">&quot;X\\n&quot;</span>;<br>        info(fmt, regname.c_str(), fri.ea, fri.value);<br>        msg(fmt, regname.c_str(), fri.ea, fri.value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>调用 <code>ask_form</code> 询问用户固定的寄存器信息，并将该值存入 <code>user_regvals</code>.<br><code>user_regvals</code> 的值通过 idb 持久化存储。</p>
<p><code>hr_callback</code> 处理 <code>hxe_microcode</code> 回调，该回调在 microcode 生成完成的时候调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This callback intercepts control as soon microcode is generated</span><br><span class="hljs-comment">// and adds necessary assertions to it. These assertions will inform</span><br><span class="hljs-comment">// the decompiler about the user-specifed register values.</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> idaapi <span class="hljs-title">plugin_ctx_t::hr_callback</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">void</span>* ud,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">hexrays_event_t</span> event,</span></span><br><span class="hljs-function"><span class="hljs-params">    va_list va)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">plugin_ctx_t</span>&amp; ctx = *(<span class="hljs-keyword">plugin_ctx_t</span>*)ud;<br>    <span class="hljs-keyword">if</span> (event == hxe_microcode)<br>    &#123;<br>        <span class="hljs-keyword">mba_t</span>* mba = va_arg(va, <span class="hljs-keyword">mba_t</span>*);<br>        ctx.insert_assertions(mba);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要逻辑还是要看 <code>insert_assertions</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">plugin_ctx_t::insert_assertions</span><span class="hljs-params">(<span class="hljs-keyword">mba_t</span>* mba)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">func_t</span>* pfn = mba-&gt;get_curfunc();<br>    <span class="hljs-keyword">if</span> (pfn == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// currently only functions are supported, not snippets</span><br><br>      <span class="hljs-comment">// filter out the addresses outside of the decompiled function</span><br>    <span class="hljs-keyword">fixed_regvals_t</span> regvals;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; rv : user_regvals) <span class="hljs-comment">// 遍历已经添加的修改项</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (func_contains(pfn, rv.ea)) <span class="hljs-comment">// 判断是否为当前函数中的修改项</span><br>            regvals.push_back(rv);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (regvals.empty())<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// no addresses inside our function</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ida_local</span> <span class="hljs-title">assertion_inserter_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">minsn_visitor_t</span><br>    &#123;<br>        <span class="hljs-keyword">fixed_regvals_t</span>&amp; regvals;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_minsn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; regvals.size(); i++)<br>            &#123;<br>                <span class="hljs-keyword">fixed_regval_info_t</span>&amp; fri = regvals[i];<br>                <span class="hljs-keyword">if</span> (curins-&gt;ea == fri.ea) <span class="hljs-comment">// 当前指令的地址与修改项的地址匹配</span><br>                &#123;<br>                    <span class="hljs-comment">// create &quot;mov #value, reg&quot;</span><br>                    <span class="hljs-keyword">minsn_t</span>* m = create_mov(fri);<br>                    <span class="hljs-comment">// insert it before the current instruction</span><br>                    blk-&gt;insert_into_block(m, curins-&gt;prev);<br>                    <span class="hljs-comment">// remove this fixed regval from consideration</span><br>                    regvals.erase(regvals.begin() + i);<br>                    --i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> regvals.empty(); <span class="hljs-comment">// stop if regvals becomes empty</span><br>        &#125;<br>        <span class="hljs-keyword">assertion_inserter_t</span>(<span class="hljs-keyword">fixed_regvals_t</span>&amp; fr) : regvals(fr) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">assertion_inserter_t</span> <span class="hljs-title">ai</span><span class="hljs-params">(regvals)</span></span>;<br><br>    <span class="hljs-comment">// find the specified addresses in mba and insert assertions.</span><br>    <span class="hljs-comment">// note: if the address specified by the user has the &#x27;nop&#x27; instruction, it</span><br>    <span class="hljs-comment">// won&#x27;t be translated into mircocode. we may fail to add an assertion because</span><br>    <span class="hljs-comment">// of this. the user should not specify the address of a &#x27;nop&#x27; instruction</span><br>    <span class="hljs-comment">// or the logic in visit_minsn() should be improved to handle the situation</span><br>    <span class="hljs-comment">// when the specified address is not present in the microcode.</span><br>    mba-&gt;for_all_topinsns(ai);<br><br>    <span class="hljs-comment">// This will work if IDA_DUMPDIR envvar points to a directory</span><br>    mba-&gt;dump();<br><br>    <span class="hljs-comment">// it is a good idea to ensure that we did not break anything</span><br>    <span class="hljs-comment">// call the verifier for that</span><br>    mba-&gt;verify(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这段代码中最核心的代码就是插入指令的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// create &quot;mov #value, reg&quot;</span><br><span class="hljs-keyword">minsn_t</span>* m = create_mov(fri);<br><span class="hljs-comment">// insert it before the current instruction</span><br>blk-&gt;insert_into_block(m, curins-&gt;prev);<br><span class="hljs-comment">// remove this fixed regval from consideration</span><br>regvals.erase(regvals.begin() + i);<br>--i;<br></code></pre></td></tr></table></figure>

<p><code>create_mov</code> 的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">minsn_t</span>* <span class="hljs-title">create_mov</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">fixed_regval_info_t</span>&amp; fri)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">minsn_t</span>* m = <span class="hljs-keyword">new</span> <span class="hljs-keyword">minsn_t</span>(fri.ea);<br>    m-&gt;opcode = m_mov;<br>    m-&gt;l.make_number(fri.value, fri.nbytes, fri.ea);<br>    m-&gt;d.make_reg(fri.reg, fri.nbytes);<br>    <span class="hljs-comment">// declare this &#x27;mov&#x27; as an assertion.</span><br>    <span class="hljs-comment">// assertions are deleted before generating ctree and don&#x27;t</span><br>    <span class="hljs-comment">// appear in the output</span><br>    m-&gt;iprops |= IPROP_ASSERT;<br>    <span class="hljs-comment">// Just for debugging let us print the constructed assertion:</span><br>    msg(<span class="hljs-string">&quot;Created insn: %s\\n&quot;</span>, m-&gt;dstr());<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入的指令被修饰为 <code>IPROP_ASSERT</code> ，即断言，不会出现在 Ctree 中，因此不会影响反编译的结果。</p>
<p>效果如下:<br>在 0x12F8 处设置 rax = 8</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled9.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>判断条件成立</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled10.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>microcode 代码如下</p>
<img src="/2021/08/19/Microcode-%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/Untitled11.png" srcset="/img/loading.gif" lazyload class="" title="Untitled">

<p>可以看出添加了一条指令（注意该指令为assertion 不会在 ctree 中呈现）</p>
<h2 id="vds19"><a href="#vds19" class="headerlink" title="vds19"></a>vds19</h2><p>这个插件添加了一条优化规则， 规则如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x | ~x =&gt; -1<br></code></pre></td></tr></table></figure>

<p>这个优化器的难点是实现 <code>x | ~x</code> 表达式的识别。</p>
<p>注册指令优化器代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">install_optinsn_handler(&amp;tiny_optimizer);<br></code></pre></td></tr></table></figure>

<p>IDA 会依次为函数的所有 top-level 指令调用优化器类的 func  函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//--------------------------------------------------------------------------</span><br><span class="hljs-comment">// a custom instruction optimizer, boilerplate code</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sample_optimizer_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">optinsn_t</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> idaapi <span class="hljs-title">func</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">mblock_t</span> *blk,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">minsn_t</span> *ins,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> <span class="hljs-comment">/*optflags*/</span>)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">subinsn_optimizer_t</span> so;<br>    ins-&gt;for_all_insns(so);<br>    <span class="hljs-keyword">if</span> ( so.cnt != <span class="hljs-number">0</span> &amp;&amp; blk != <span class="hljs-literal">nullptr</span> ) <span class="hljs-comment">// if we modified microcode,</span><br>      blk-&gt;mba-&gt;verify(<span class="hljs-literal">true</span>);            <span class="hljs-comment">// run the verifier</span><br>    <span class="hljs-keyword">return</span> so.cnt;                       <span class="hljs-comment">// report the number of changes</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 top 指令级并不能完成什么有实际性的优化工作，为了识别子表达式，继承 <code>minsn_visitor_t</code> 类实现了一个子指令遍历类，实现了具体的优化任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// recognize &quot;x | ~x&quot; and replace by -1</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subinsn_optimizer_t</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">minsn_visitor_t</span><br>&#123;<br>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> idaapi <span class="hljs-title">visit_minsn</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-comment">// for each instruction...</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// THE CORE OF THE PLUGIN IS HERE:</span><br>    <span class="hljs-comment">// check the pattern &quot;x | ~x&quot;</span><br>    <span class="hljs-keyword">if</span> ( curins-&gt;opcode == m_or<br>      &amp;&amp; curins-&gt;r.is_insn(m_bnot)<br>      &amp;&amp; curins-&gt;l == curins-&gt;r.d-&gt;l )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !curins-&gt;l.has_side_effects() ) <span class="hljs-comment">// avoid destroying side effects</span><br>      &#123;<br>        <span class="hljs-comment">// pattern matched, convert to &quot;mov -1, ...&quot;</span><br>        curins-&gt;opcode = m_mov;<br>        curins-&gt;l.make_number(<span class="hljs-number">-1</span>, curins-&gt;r.size);<br>        curins-&gt;r.erase();<br>        cnt = cnt + <span class="hljs-number">1</span>; <span class="hljs-comment">// number of changes we made</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// continue traversal</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>逻辑比较简单，遍历指令过程中若遇到 <code>x | ~x</code> 表达式，则将其替换成 <code>mov -1</code> 指令。</p>
<p>通过代码可以看出，这种优化只能处理 not 是 or 的子指令的情况，IDA 设计的指令嵌套确实很方便这种优化，可以不要考虑 删除掉  not 或 or 对于其它指令的影响。</p>
<h2 id="vds20"><a href="#vds20" class="headerlink" title="vds20"></a>vds20</h2><p>好像与mircocode 无关就不写了。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Microcode/">Microcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Reverse/">Reverse</a>
                    
                      <a class="hover-with-bg" href="/tags/IDA/">IDA</a>
                    
                      <a class="hover-with-bg" href="/tags/Microcode/">Microcode</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/16/InCTF2021/">
                        <span class="hidden-mobile">InCTF2021</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: '2e60164d74c132464b61',
          clientSecret: '52a91b30d8b32af23cbb6d7c3ce8950d27240133',
          repo: 'P4nda0s.github.io',
          owner: 'P4nda0s',
          admin: ["P4nda0s"],
          id: 'c20840d017565cf79409f2b54f2e29bf',
          language: 'zh-CN',
          labels: ["Gitalk"],
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: true,
          distractionFreeMode: true,
          proxy: 'https://purple-cell-2422.pandaos.workers.dev/?https://github.com/login/oauth/access_token'
        });
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
